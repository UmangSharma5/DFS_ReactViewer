{"ast":null,"code":"import _objectWithoutProperties from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar _excluded = [\"headers\", \"credentials\", \"maxRanges\", \"allowFullFile\"],\n  _excluded2 = [\"headers\", \"maxRanges\", \"allowFullFile\"],\n  _excluded3 = [\"headers\", \"maxRanges\", \"allowFullFile\"],\n  _excluded4 = [\"forceXHR\"];\nimport { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\nvar RemoteSource = /*#__PURE__*/function (_BaseSource) {\n  _inherits(RemoteSource, _BaseSource);\n  var _super = _createSuper(RemoteSource);\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  function RemoteSource(client, headers, maxRanges, allowFullFile) {\n    var _this;\n    _classCallCheck(this, RemoteSource);\n    _this = _super.call(this);\n    _this.client = client;\n    _this.headers = headers;\n    _this.maxRanges = maxRanges;\n    _this.allowFullFile = allowFullFile;\n    _this._fileSize = null;\n    return _this;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  _createClass(RemoteSource, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(slices, signal) {\n        var _this2 = this;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.maxRanges >= slices.length)) {\n                _context.next = 4;\n                break;\n              }\n              return _context.abrupt(\"return\", this.fetchSlices(slices, signal));\n            case 4:\n              if (this.maxRanges > 0 && slices.length > 1) {\n                // TODO: split into multiple multi-range requests\n\n                // const subSlicesRequests = [];\n                // for (let i = 0; i < slices.length; i += this.maxRanges) {\n                //   subSlicesRequests.push(\n                //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n                //   );\n                // }\n                // return (await Promise.all(subSlicesRequests)).flat();\n              }\n            case 5:\n              return _context.abrupt(\"return\", Promise.all(slices.map(function (slice) {\n                return _this2.fetchSlice(slice, signal);\n              })));\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function fetch(_x, _x2) {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n  }, {\n    key: \"fetchSlices\",\n    value: function () {\n      var _fetchSlices = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(slices, signal) {\n        var _this3 = this;\n        var response, _parseContentType, type, params, byteRanges, data, _parseContentRange, start, end, total, first, others, _data;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.client.request({\n                headers: _objectSpread(_objectSpread({}, this.headers), {}, {\n                  Range: \"bytes=\".concat(slices.map(function (_ref) {\n                    var offset = _ref.offset,\n                      length = _ref.length;\n                    return \"\".concat(offset, \"-\").concat(offset + length);\n                  }).join(','))\n                }),\n                signal: signal\n              });\n            case 2:\n              response = _context2.sent;\n              if (response.ok) {\n                _context2.next = 7;\n                break;\n              }\n              throw new Error('Error fetching data.');\n            case 7:\n              if (!(response.status === 206)) {\n                _context2.next = 32;\n                break;\n              }\n              _parseContentType = parseContentType(response.getHeader('content-type')), type = _parseContentType.type, params = _parseContentType.params;\n              if (!(type === 'multipart/byteranges')) {\n                _context2.next = 18;\n                break;\n              }\n              _context2.t0 = parseByteRanges;\n              _context2.next = 13;\n              return response.getData();\n            case 13:\n              _context2.t1 = _context2.sent;\n              _context2.t2 = params.boundary;\n              byteRanges = (0, _context2.t0)(_context2.t1, _context2.t2);\n              this._fileSize = byteRanges[0].fileSize || null;\n              return _context2.abrupt(\"return\", byteRanges);\n            case 18:\n              _context2.next = 20;\n              return response.getData();\n            case 20:\n              data = _context2.sent;\n              _parseContentRange = parseContentRange(response.getHeader('content-range')), start = _parseContentRange.start, end = _parseContentRange.end, total = _parseContentRange.total;\n              this._fileSize = total || null;\n              first = [{\n                data: data,\n                offset: start,\n                length: end - start\n              }];\n              if (!(slices.length > 1)) {\n                _context2.next = 29;\n                break;\n              }\n              _context2.next = 27;\n              return Promise.all(slices.slice(1).map(function (slice) {\n                return _this3.fetchSlice(slice, signal);\n              }));\n            case 27:\n              others = _context2.sent;\n              return _context2.abrupt(\"return\", first.concat(others));\n            case 29:\n              return _context2.abrupt(\"return\", first);\n            case 32:\n              if (this.allowFullFile) {\n                _context2.next = 34;\n                break;\n              }\n              throw new Error('Server responded with full file');\n            case 34:\n              _context2.next = 36;\n              return response.getData();\n            case 36:\n              _data = _context2.sent;\n              this._fileSize = _data.byteLength;\n              return _context2.abrupt(\"return\", [{\n                data: _data,\n                offset: 0,\n                length: _data.byteLength\n              }]);\n            case 39:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function fetchSlices(_x3, _x4) {\n        return _fetchSlices.apply(this, arguments);\n      }\n      return fetchSlices;\n    }()\n  }, {\n    key: \"fetchSlice\",\n    value: function () {\n      var _fetchSlice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(slice, signal) {\n        var offset, length, response, data, _parseContentRange2, total, _data2;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              offset = slice.offset, length = slice.length;\n              _context3.next = 3;\n              return this.client.request({\n                headers: _objectSpread(_objectSpread({}, this.headers), {}, {\n                  Range: \"bytes=\".concat(offset, \"-\").concat(offset + length)\n                }),\n                signal: signal\n              });\n            case 3:\n              response = _context3.sent;\n              if (response.ok) {\n                _context3.next = 8;\n                break;\n              }\n              throw new Error('Error fetching data.');\n            case 8:\n              if (!(response.status === 206)) {\n                _context3.next = 17;\n                break;\n              }\n              _context3.next = 11;\n              return response.getData();\n            case 11:\n              data = _context3.sent;\n              _parseContentRange2 = parseContentRange(response.getHeader('content-range')), total = _parseContentRange2.total;\n              this._fileSize = total || null;\n              return _context3.abrupt(\"return\", {\n                data: data,\n                offset: offset,\n                length: length\n              });\n            case 17:\n              if (this.allowFullFile) {\n                _context3.next = 19;\n                break;\n              }\n              throw new Error('Server responded with full file');\n            case 19:\n              _context3.next = 21;\n              return response.getData();\n            case 21:\n              _data2 = _context3.sent;\n              this._fileSize = _data2.byteLength;\n              return _context3.abrupt(\"return\", {\n                data: _data2,\n                offset: 0,\n                length: _data2.byteLength\n              });\n            case 24:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function fetchSlice(_x5, _x6) {\n        return _fetchSlice.apply(this, arguments);\n      }\n      return fetchSlice;\n    }()\n  }, {\n    key: \"fileSize\",\n    get: function get() {\n      return this._fileSize;\n    }\n  }]);\n  return RemoteSource;\n}(BaseSource);\nfunction maybeWrapInBlockedSource(source, _ref2) {\n  var blockSize = _ref2.blockSize,\n    cacheSize = _ref2.cacheSize;\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, {\n    blockSize: blockSize,\n    cacheSize: cacheSize\n  });\n}\nexport function makeFetchSource(url) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref3$headers = _ref3.headers,\n    headers = _ref3$headers === void 0 ? {} : _ref3$headers,\n    credentials = _ref3.credentials,\n    _ref3$maxRanges = _ref3.maxRanges,\n    maxRanges = _ref3$maxRanges === void 0 ? 0 : _ref3$maxRanges,\n    _ref3$allowFullFile = _ref3.allowFullFile,\n    allowFullFile = _ref3$allowFullFile === void 0 ? false : _ref3$allowFullFile,\n    blockOptions = _objectWithoutProperties(_ref3, _excluded);\n  var client = new FetchClient(url, credentials);\n  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeXHRSource(url) {\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref4$headers = _ref4.headers,\n    headers = _ref4$headers === void 0 ? {} : _ref4$headers,\n    _ref4$maxRanges = _ref4.maxRanges,\n    maxRanges = _ref4$maxRanges === void 0 ? 0 : _ref4$maxRanges,\n    _ref4$allowFullFile = _ref4.allowFullFile,\n    allowFullFile = _ref4$allowFullFile === void 0 ? false : _ref4$allowFullFile,\n    blockOptions = _objectWithoutProperties(_ref4, _excluded2);\n  var client = new XHRClient(url);\n  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeHttpSource(url) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref5$headers = _ref5.headers,\n    headers = _ref5$headers === void 0 ? {} : _ref5$headers,\n    _ref5$maxRanges = _ref5.maxRanges,\n    maxRanges = _ref5$maxRanges === void 0 ? 0 : _ref5$maxRanges,\n    _ref5$allowFullFile = _ref5.allowFullFile,\n    allowFullFile = _ref5$allowFullFile === void 0 ? false : _ref5$allowFullFile,\n    blockOptions = _objectWithoutProperties(_ref5, _excluded3);\n  var client = new HttpClient(url);\n  var source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url) {\n  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref6$forceXHR = _ref6.forceXHR,\n    forceXHR = _ref6$forceXHR === void 0 ? false : _ref6$forceXHR,\n    clientOptions = _objectWithoutProperties(_ref6, _excluded4);\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}","map":{"version":3,"names":["parseByteRanges","parseContentRange","parseContentType","BaseSource","BlockedSource","FetchClient","XHRClient","HttpClient","RemoteSource","_BaseSource","_inherits","_super","_createSuper","client","headers","maxRanges","allowFullFile","_this","_classCallCheck","call","_fileSize","_createClass","key","value","_fetch","_asyncToGenerator","_regeneratorRuntime","mark","_callee","slices","signal","_this2","wrap","_callee$","_context","prev","next","length","abrupt","fetchSlices","Promise","all","map","slice","fetchSlice","stop","fetch","_x","_x2","apply","arguments","_fetchSlices","_callee2","_this3","response","_parseContentType","type","params","byteRanges","data","_parseContentRange","start","end","total","first","others","_data","_callee2$","_context2","request","_objectSpread","Range","concat","_ref","offset","join","sent","ok","Error","status","getHeader","t0","getData","t1","t2","boundary","fileSize","byteLength","_x3","_x4","_fetchSlice","_callee3","_parseContentRange2","_data2","_callee3$","_context3","_x5","_x6","get","maybeWrapInBlockedSource","source","_ref2","blockSize","cacheSize","makeFetchSource","url","_ref3","undefined","_ref3$headers","credentials","_ref3$maxRanges","_ref3$allowFullFile","blockOptions","_objectWithoutProperties","_excluded","makeXHRSource","_ref4","_ref4$headers","_ref4$maxRanges","_ref4$allowFullFile","_excluded2","makeHttpSource","_ref5","_ref5$headers","_ref5$maxRanges","_ref5$allowFullFile","_excluded3","makeRemoteSource","_ref6","_ref6$forceXHR","forceXHR","clientOptions","_excluded4","XMLHttpRequest"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/geotiff/dist-module/source/remote.js"],"sourcesContent":["import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}