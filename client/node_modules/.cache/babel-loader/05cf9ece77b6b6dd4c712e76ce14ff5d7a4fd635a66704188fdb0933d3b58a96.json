{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\nvar tagName2Code = invert(fieldTagNames);\nvar geoKeyName2Code = invert(geoKeyNames);\nvar name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nvar typeName2byte = invert(fieldTypeNames);\n\n// config variables\nvar numBytesInIfd = 1000;\nvar _binBE = {\n  nextZero: function nextZero(data, o) {\n    var oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: function readUshort(buff, p) {\n    return buff[p] << 8 | buff[p + 1];\n  },\n  readShort: function readShort(buff, p) {\n    var a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: function readInt(buff, p) {\n    var a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: function readUint(buff, p) {\n    var a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: function readASCII(buff, p, l) {\n    return l.map(function (i) {\n      return String.fromCharCode(buff[p + i]);\n    }).join('');\n  },\n  readFloat: function readFloat(buff, p) {\n    var a = _binBE.ui8;\n    times(4, function (i) {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: function readDouble(buff, p) {\n    var a = _binBE.ui8;\n    times(8, function (i) {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: function writeUshort(buff, p, n) {\n    buff[p] = n >> 8 & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: function writeUint(buff, p, n) {\n    buff[p] = n >> 24 & 255;\n    buff[p + 1] = n >> 16 & 255;\n    buff[p + 2] = n >> 8 & 255;\n    buff[p + 3] = n >> 0 & 255;\n  },\n  writeASCII: function writeASCII(buff, p, s) {\n    times(s.length, function (i) {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8)\n};\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n_binBE.writeDouble = function (buff, p, n) {\n  _binBE.fl64[0] = n;\n  times(8, function (i) {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\nvar _writeIFD = function _writeIFD(bin, data, _offset, ifd) {\n  var offset = _offset;\n  var keys = Object.keys(ifd).filter(function (key) {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n  var eoff = offset + 12 * keys.length + 4;\n  var _iterator = _createForOfIteratorHelper(keys),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var key = _step.value;\n      var tag = null;\n      if (typeof key === 'number') {\n        tag = key;\n      } else if (typeof key === 'string') {\n        tag = parseInt(key, 10);\n      }\n      var typeName = fieldTagTypes[tag];\n      var typeNum = typeName2byte[typeName];\n      if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n        throw new Error(\"unknown type of tag: \".concat(tag));\n      }\n      var val = ifd[key];\n      if (val === undefined) {\n        throw new Error(\"failed to get value for key \".concat(key));\n      }\n\n      // ASCIIZ format with trailing 0 character\n      // http://www.fileformat.info/format/tiff/corion.htm\n      // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n      if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, \"\\0\") === false) {\n        val += \"\\0\";\n      }\n      var num = val.length;\n      bin.writeUshort(data, offset, tag);\n      offset += 2;\n      bin.writeUshort(data, offset, typeNum);\n      offset += 2;\n      bin.writeUint(data, offset, num);\n      offset += 4;\n      var dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n      var toff = offset;\n      if (dlen > 4) {\n        bin.writeUint(data, offset, eoff);\n        toff = eoff;\n      }\n      if (typeName === 'ASCII') {\n        bin.writeASCII(data, toff, val);\n      } else if (typeName === 'SHORT') {\n        times(num, function (i) {\n          bin.writeUshort(data, toff + 2 * i, val[i]);\n        });\n      } else if (typeName === 'LONG') {\n        times(num, function (i) {\n          bin.writeUint(data, toff + 4 * i, val[i]);\n        });\n      } else if (typeName === 'RATIONAL') {\n        times(num, function (i) {\n          bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 10000));\n          bin.writeUint(data, toff + 8 * i + 4, 10000);\n        });\n      } else if (typeName === 'DOUBLE') {\n        times(num, function (i) {\n          bin.writeDouble(data, toff + 8 * i, val[i]);\n        });\n      }\n      if (dlen > 4) {\n        dlen += dlen & 1;\n        eoff += dlen;\n      }\n      offset += 4;\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return [offset, eoff];\n};\nvar encodeIfds = function encodeIfds(ifds) {\n  var data = new Uint8Array(numBytesInIfd);\n  var offset = 4;\n  var bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n  var ifdo = 8;\n  bin.writeUint(data, offset, ifdo);\n  offset += 4;\n  ifds.forEach(function (ifd, i) {\n    var noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  var result = new Uint8Array(ifdo);\n  for (var i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\nvar encodeImage = function encodeImage(values, width, height, metadata) {\n  if (height === undefined || height === null) {\n    throw new Error(\"you passed into encodeImage a width of type \".concat(height));\n  }\n  if (width === undefined || width === null) {\n    throw new Error(\"you passed into encodeImage a width of type \".concat(width));\n  }\n  var ifd = {\n    256: [width],\n    // ImageWidth\n    257: [height],\n    // ImageLength\n    273: [numBytesInIfd],\n    // strips offset\n    278: [height],\n    // RowsPerStrip\n    305: 'geotiff.js' // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (var i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n  var prfx = new Uint8Array(encodeIfds([ifd]));\n  var img = new Uint8Array(values);\n  var samplesPerPixel = ifd[277];\n  var data = new Uint8Array(numBytesInIfd + width * height * samplesPerPixel);\n  times(prfx.length, function (i) {\n    data[i] = prfx[i];\n  });\n  forEach(img, function (value, i) {\n    data[numBytesInIfd + i] = value;\n  });\n  return data.buffer;\n};\nvar convertToTids = function convertToTids(input) {\n  var result = {};\n  for (var key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\nvar toArray = function toArray(input) {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\nvar metadataDefaults = [['Compression', 1],\n// no compression\n['PlanarConfiguration', 1], ['ExtraSamples', 0]];\nexport function writeGeotiff(data, metadata) {\n  var isFlattened = typeof data[0] === 'number';\n  var height;\n  var numBands;\n  var width;\n  var flattenedValues;\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, function (rowIndex) {\n      times(width, function (columnIndex) {\n        times(numBands, function (bandIndex) {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, function () {\n      return 8;\n    });\n  }\n  metadataDefaults.forEach(function (tag) {\n    var key = tag[0];\n    if (!metadata[key]) {\n      var value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, function () {\n      return 1;\n    });\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n  var geoKeys = Object.keys(metadata).filter(function (key) {\n    return endsWith(key, 'GeoKey');\n  }).sort(function (a, b) {\n    return name2code[a] - name2code[b];\n  });\n  if (!metadata.GeoAsciiParams) {\n    var geoAsciiParams = '';\n    geoKeys.forEach(function (name) {\n      var code = Number(name2code[name]);\n      var tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += \"\".concat(metadata[name].toString(), \"\\0\");\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n  if (!metadata.GeoKeyDirectory) {\n    var NumberOfKeys = geoKeys.length;\n    var GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach(function (geoKey) {\n      var KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n      var Count;\n      var TIFFTagLocation;\n      var valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(\"[geotiff.js] couldn't get TIFFTagLocation for \".concat(geoKey));\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (var geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n  ['Compression', 'ExtraSamples', 'GeographicTypeGeoKey', 'GTModelTypeGeoKey', 'GTRasterTypeGeoKey', 'ImageLength',\n  // synonym of ImageHeight\n  'ImageWidth', 'Orientation', 'PhotometricInterpretation', 'ProjectedCSTypeGeoKey', 'PlanarConfiguration', 'ResolutionUnit', 'SamplesPerPixel', 'XPosition', 'YPosition'].forEach(function (name) {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n  var encodedMetadata = convertToTids(metadata);\n  var outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n  return outputImage;\n}","map":{"version":3,"names":["fieldTagNames","fieldTagTypes","fieldTypeNames","geoKeyNames","assign","endsWith","forEach","invert","times","tagName2Code","geoKeyName2Code","name2code","typeName2byte","numBytesInIfd","_binBE","nextZero","data","o","oincr","readUshort","buff","p","readShort","a","ui8","i16","readInt","i32","readUint","ui32","readASCII","l","map","i","String","fromCharCode","join","readFloat","fl32","readDouble","fl64","writeUshort","n","writeUint","writeASCII","s","length","charCodeAt","Uint8Array","Float64Array","buffer","writeDouble","_writeIFD","bin","_offset","ifd","offset","keys","Object","filter","key","undefined","eoff","_iterator","_createForOfIteratorHelper","_step","_loop","value","tag","parseInt","typeName","typeNum","Error","concat","val","num","dlen","toff","Math","round","done","err","e","f","encodeIfds","ifds","ifdo","noffs","slice","result","encodeImage","values","width","height","metadata","hasOwnProperty","prfx","img","samplesPerPixel","convertToTids","input","console","error","toArray","Array","isArray","metadataDefaults","writeGeotiff","isFlattened","numBands","flattenedValues","ImageLength","ImageWidth","rowIndex","columnIndex","bandIndex","push","BitsPerSample","PhotometricInterpretation","SamplesPerPixel","StripByteCounts","ModelPixelScale","SampleFormat","GeographicTypeGeoKey","ModelTiepoint","GeogCitationGeoKey","GTModelTypeGeoKey","geoKeys","sort","b","GeoAsciiParams","geoAsciiParams","name","code","Number","tagType","toString","GeoKeyDirectory","NumberOfKeys","geoKey","KeyID","Count","TIFFTagLocation","valueOffset","log","encodedMetadata","outputImage"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/geotiff/dist-module/geotiffwriter.js"],"sourcesContent":["/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}