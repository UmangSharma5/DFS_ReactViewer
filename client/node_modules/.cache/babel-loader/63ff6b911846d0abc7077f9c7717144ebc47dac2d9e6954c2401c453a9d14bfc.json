{"ast":null,"code":"import _classCallCheck from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport BaseDecoder from './basedecoder.js';\nvar MIN_BITS = 9;\nvar CLEAR_CODE = 256; // clear code\nvar EOI_CODE = 257; // end of information\nvar MAX_BYTELENGTH = 12;\nfunction getByte(array, position, length) {\n  var d = position % 8;\n  var a = Math.floor(position / 8);\n  var de = 8 - d;\n  var ef = position + length - (a + 1) * 8;\n  var fg = 8 * (a + 2) - (position + length);\n  var dg = (a + 2) * 8 - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  var chunk1 = array[a] & Math.pow(2, 8 - d) - 1;\n  chunk1 <<= length - de;\n  var chunks = chunk1;\n  if (a + 1 < array.length) {\n    var chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, length - dg);\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    var hi = (a + 3) * 8 - (position + length);\n    var chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\nfunction appendReversed(dest, source) {\n  for (var i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\nfunction decompress(input) {\n  var dictionaryIndex = new Uint16Array(4093);\n  var dictionaryChar = new Uint8Array(4093);\n  for (var i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  var dictionaryLength = 258;\n  var byteLength = MIN_BITS;\n  var position = 0;\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    var byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    var rev = [];\n    for (var _i = n; _i !== 4096; _i = dictionaryIndex[_i]) {\n      rev.push(dictionaryChar[_i]);\n    }\n    return rev;\n  }\n  var result = [];\n  initDictionary();\n  var array = new Uint8Array(input);\n  var code = getNext(array);\n  var oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(\"corrupted code at scanline \".concat(code));\n      } else {\n        var val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      var _val = getDictionaryReversed(code);\n      appendReversed(result, _val);\n      addToDictionary(oldCode, _val[_val.length - 1]);\n      oldCode = code;\n    } else {\n      var oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(\"Bogus entry. Not in dictionary, \".concat(oldCode, \" / \").concat(dictionaryLength, \", position: \").concat(position));\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n    if (dictionaryLength + 1 >= Math.pow(2, byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\nvar LZWDecoder = /*#__PURE__*/function (_BaseDecoder) {\n  _inherits(LZWDecoder, _BaseDecoder);\n  var _super = _createSuper(LZWDecoder);\n  function LZWDecoder() {\n    _classCallCheck(this, LZWDecoder);\n    return _super.apply(this, arguments);\n  }\n  _createClass(LZWDecoder, [{\n    key: \"decodeBlock\",\n    value: function decodeBlock(buffer) {\n      return decompress(buffer, false).buffer;\n    }\n  }]);\n  return LZWDecoder;\n}(BaseDecoder);\nexport { LZWDecoder as default };","map":{"version":3,"names":["BaseDecoder","MIN_BITS","CLEAR_CODE","EOI_CODE","MAX_BYTELENGTH","getByte","array","position","length","d","a","Math","floor","de","ef","fg","dg","max","console","warn","chunk1","pow","chunks","chunk2","hi","chunk3","appendReversed","dest","source","i","push","decompress","input","dictionaryIndex","Uint16Array","dictionaryChar","Uint8Array","dictionaryLength","byteLength","initDictionary","getNext","byte","addToDictionary","c","getDictionaryReversed","n","rev","result","code","oldCode","Error","concat","val","oldVal","undefined","LZWDecoder","_BaseDecoder","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","decodeBlock","buffer","default"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/geotiff/dist-module/compression/lzw.js"],"sourcesContent":["import BaseDecoder from './basedecoder.js';\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nexport default class LZWDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}