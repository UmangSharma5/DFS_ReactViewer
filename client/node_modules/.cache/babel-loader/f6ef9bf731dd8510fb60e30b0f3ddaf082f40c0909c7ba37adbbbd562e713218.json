{"ast":null,"code":"import _toArray from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _slicedToArray from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  var obj = {};\n  var _iterator = _createForOfIteratorHelper(items),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        key = _step$value[0],\n        value = _step$value[1];\n      obj[key.toLowerCase()] = value;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  var items = text.split('\\r\\n').map(function (line) {\n    var kv = line.split(':').map(function (str) {\n      return str.trim();\n    });\n    kv[0] = kv[0].toLowerCase();\n    return kv;\n  });\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  var _rawContentType$split = rawContentType.split(';').map(function (s) {\n      return s.trim();\n    }),\n    _rawContentType$split2 = _toArray(_rawContentType$split),\n    type = _rawContentType$split2[0],\n    rawParams = _rawContentType$split2.slice(1);\n  var paramsItems = rawParams.map(function (param) {\n    return param.split('=');\n  });\n  return {\n    type: type,\n    params: itemsToObject(paramsItems)\n  };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  var start;\n  var end;\n  var total;\n  if (rawContentRange) {\n    var _rawContentRange$matc = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    var _rawContentRange$matc2 = _slicedToArray(_rawContentRange$matc, 4);\n    start = _rawContentRange$matc2[1];\n    end = _rawContentRange$matc2[2];\n    total = _rawContentRange$matc2[3];\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n  return {\n    start: start,\n    end: end,\n    total: total\n  };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  var offset = null;\n  var decoder = new TextDecoder('ascii');\n  var out = [];\n  var startBoundary = \"--\".concat(boundary);\n  var endBoundary = \"\".concat(startBoundary, \"--\");\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (var i = 0; i < 10; ++i) {\n    var text = decoder.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n  while (offset < responseArrayBuffer.byteLength) {\n    var _text = decoder.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset)));\n\n    // break if we arrived at the end\n    if (_text.length === 0 || _text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!_text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    var innerText = _text.substr(startBoundary.length + 2);\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    var endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    var headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    var _parseContentRange = parseContentRange(headers['content-range']),\n      start = _parseContentRange.start,\n      end = _parseContentRange.end,\n      total = _parseContentRange.total;\n\n    // calculate the length of the slice and the next offset\n    var startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    var length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers: headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length: length,\n      fileSize: total\n    });\n    offset = startOfData + length + 4;\n  }\n  return out;\n}","map":{"version":3,"names":["CRLFCRLF","itemsToObject","items","Object","fromEntries","obj","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","value","key","toLowerCase","err","e","f","parseHeaders","text","split","map","line","kv","str","trim","parseContentType","rawContentType","_rawContentType$split","_rawContentType$split2","_toArray","type","rawParams","slice","paramsItems","param","params","parseContentRange","rawContentRange","start","end","total","_rawContentRange$matc","match","_rawContentRange$matc2","parseInt","parseByteRanges","responseArrayBuffer","boundary","offset","decoder","TextDecoder","out","startBoundary","concat","endBoundary","i","decode","Uint8Array","length","Error","byteLength","Math","min","startsWith","innerText","substr","endOfHeaders","indexOf","headers","_parseContentRange","startOfData","push","data","fileSize"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/geotiff/dist-module/source/httputils.js"],"sourcesContent":["const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n"],"mappings":";;;AAAA,IAAMA,QAAQ,GAAG,UAAU;;AAE3B;AACA;AACA;AACA,SAASC,aAAaA,CAACC,KAAK,EAAE;EAC5B,IAAI,OAAOC,MAAM,CAACC,WAAW,KAAK,WAAW,EAAE;IAC7C,OAAOD,MAAM,CAACC,WAAW,CAACF,KAAK,CAAC;EAClC;EACA,IAAMG,GAAG,GAAG,CAAC,CAAC;EAAC,IAAAC,SAAA,GAAAC,0BAAA,CACYL,KAAK;IAAAM,KAAA;EAAA;IAAhC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAkC;MAAA,IAAAC,WAAA,GAAAC,cAAA,CAAAL,KAAA,CAAAM,KAAA;QAAtBC,GAAG,GAAAH,WAAA;QAAEE,KAAK,GAAAF,WAAA;MACpBP,GAAG,CAACU,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC,GAAGF,KAAK;IAChC;EAAC,SAAAG,GAAA;IAAAX,SAAA,CAAAY,CAAA,CAAAD,GAAA;EAAA;IAAAX,SAAA,CAAAa,CAAA;EAAA;EACD,OAAOd,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASe,YAAYA,CAACC,IAAI,EAAE;EAC1B,IAAMnB,KAAK,GAAGmB,IAAI,CACfC,KAAK,CAAC,MAAM,CAAC,CACbC,GAAG,CAAC,UAACC,IAAI,EAAK;IACb,IAAMC,EAAE,GAAGD,IAAI,CAACF,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,UAACG,GAAG;MAAA,OAAKA,GAAG,CAACC,IAAI,CAAC,CAAC;IAAA,EAAC;IACnDF,EAAE,CAAC,CAAC,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,CAACT,WAAW,CAAC,CAAC;IAC3B,OAAOS,EAAE;EACX,CAAC,CAAC;EAEJ,OAAOxB,aAAa,CAACC,KAAK,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS0B,gBAAgBA,CAACC,cAAc,EAAE;EAC/C,IAAAC,qBAAA,GAA6BD,cAAc,CAACP,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,UAACd,CAAC;MAAA,OAAKA,CAAC,CAACkB,IAAI,CAAC,CAAC;IAAA,EAAC;IAAAI,sBAAA,GAAAC,QAAA,CAAAF,qBAAA;IAApEG,IAAI,GAAAF,sBAAA;IAAKG,SAAS,GAAAH,sBAAA,CAAAI,KAAA;EACzB,IAAMC,WAAW,GAAGF,SAAS,CAACX,GAAG,CAAC,UAACc,KAAK;IAAA,OAAKA,KAAK,CAACf,KAAK,CAAC,GAAG,CAAC;EAAA,EAAC;EAC9D,OAAO;IAAEW,IAAI,EAAJA,IAAI;IAAEK,MAAM,EAAErC,aAAa,CAACmC,WAAW;EAAE,CAAC;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,iBAAiBA,CAACC,eAAe,EAAE;EACjD,IAAIC,KAAK;EACT,IAAIC,GAAG;EACP,IAAIC,KAAK;EAET,IAAIH,eAAe,EAAE;IAAA,IAAAI,qBAAA,GACKJ,eAAe,CAACK,KAAK,CAAC,0BAA0B,CAAC;IAAA,IAAAC,sBAAA,GAAAjC,cAAA,CAAA+B,qBAAA;IAAtEH,KAAK,GAAAK,sBAAA;IAAEJ,GAAG,GAAAI,sBAAA;IAAEH,KAAK,GAAAG,sBAAA;IACpBL,KAAK,GAAGM,QAAQ,CAACN,KAAK,EAAE,EAAE,CAAC;IAC3BC,GAAG,GAAGK,QAAQ,CAACL,GAAG,EAAE,EAAE,CAAC;IACvBC,KAAK,GAAGI,QAAQ,CAACJ,KAAK,EAAE,EAAE,CAAC;EAC7B;EAEA,OAAO;IAAEF,KAAK,EAALA,KAAK;IAAEC,GAAG,EAAHA,GAAG;IAAEC,KAAK,EAALA;EAAM,CAAC;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,eAAeA,CAACC,mBAAmB,EAAEC,QAAQ,EAAE;EAC7D,IAAIC,MAAM,GAAG,IAAI;EACjB,IAAMC,OAAO,GAAG,IAAIC,WAAW,CAAC,OAAO,CAAC;EACxC,IAAMC,GAAG,GAAG,EAAE;EAEd,IAAMC,aAAa,QAAAC,MAAA,CAAQN,QAAQ,CAAE;EACrC,IAAMO,WAAW,MAAAD,MAAA,CAAMD,aAAa,OAAI;;EAExC;EACA;EACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAE,EAAEA,CAAC,EAAE;IAC3B,IAAMrC,IAAI,GAAG+B,OAAO,CAACO,MAAM,CACzB,IAAIC,UAAU,CAACX,mBAAmB,EAAES,CAAC,EAAEH,aAAa,CAACM,MAAM,CAC7D,CAAC;IACD,IAAIxC,IAAI,KAAKkC,aAAa,EAAE;MAC1BJ,MAAM,GAAGO,CAAC;IACZ;EACF;EAEA,IAAIP,MAAM,KAAK,IAAI,EAAE;IACnB,MAAM,IAAIW,KAAK,CAAC,iCAAiC,CAAC;EACpD;EAEA,OAAOX,MAAM,GAAGF,mBAAmB,CAACc,UAAU,EAAE;IAC9C,IAAM1C,KAAI,GAAG+B,OAAO,CAACO,MAAM,CACzB,IAAIC,UAAU,CAACX,mBAAmB,EAAEE,MAAM,EACxCa,IAAI,CAACC,GAAG,CAACV,aAAa,CAACM,MAAM,GAAG,IAAI,EAAEZ,mBAAmB,CAACc,UAAU,GAAGZ,MAAM,CAC/E,CACF,CAAC;;IAED;IACA,IAAI9B,KAAI,CAACwC,MAAM,KAAK,CAAC,IAAIxC,KAAI,CAAC6C,UAAU,CAACT,WAAW,CAAC,EAAE;MACrD;IACF;;IAEA;IACA,IAAI,CAACpC,KAAI,CAAC6C,UAAU,CAACX,aAAa,CAAC,EAAE;MACnC,MAAM,IAAIO,KAAK,CAAC,mCAAmC,CAAC;IACtD;;IAEA;IACA,IAAMK,SAAS,GAAG9C,KAAI,CAAC+C,MAAM,CAACb,aAAa,CAACM,MAAM,GAAG,CAAC,CAAC;IAEvD,IAAIM,SAAS,CAACN,MAAM,KAAK,CAAC,EAAE;MAC1B;IACF;;IAEA;IACA,IAAMQ,YAAY,GAAGF,SAAS,CAACG,OAAO,CAACtE,QAAQ,CAAC;;IAEhD;IACA,IAAMuE,OAAO,GAAGnD,YAAY,CAAC+C,SAAS,CAACC,MAAM,CAAC,CAAC,EAAEC,YAAY,CAAC,CAAC;IAC/D,IAAAG,kBAAA,GAA8BjC,iBAAiB,CAACgC,OAAO,CAAC,eAAe,CAAC,CAAC;MAAjE9B,KAAK,GAAA+B,kBAAA,CAAL/B,KAAK;MAAEC,GAAG,GAAA8B,kBAAA,CAAH9B,GAAG;MAAEC,KAAK,GAAA6B,kBAAA,CAAL7B,KAAK;;IAEzB;IACA,IAAM8B,WAAW,GAAGtB,MAAM,GAAGI,aAAa,CAACM,MAAM,GAAGQ,YAAY,GAAGrE,QAAQ,CAAC6D,MAAM;IAClF,IAAMA,MAAM,GAAGd,QAAQ,CAACL,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,GAAGK,QAAQ,CAACN,KAAK,EAAE,EAAE,CAAC;IAC1Da,GAAG,CAACoB,IAAI,CAAC;MACPH,OAAO,EAAPA,OAAO;MACPI,IAAI,EAAE1B,mBAAmB,CAACd,KAAK,CAACsC,WAAW,EAAEA,WAAW,GAAGZ,MAAM,CAAC;MAClEV,MAAM,EAAEV,KAAK;MACboB,MAAM,EAANA,MAAM;MACNe,QAAQ,EAAEjC;IACZ,CAAC,CAAC;IAEFQ,MAAM,GAAGsB,WAAW,GAAGZ,MAAM,GAAG,CAAC;EACnC;EAEA,OAAOP,GAAG;AACZ"},"metadata":{},"sourceType":"module","externalDependencies":[]}