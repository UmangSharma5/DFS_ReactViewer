{"ast":null,"code":"import _inherits from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport BaseDecoder from './basedecoder.js';\n\n/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nvar dctZigZag = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);\nvar dctCos1 = 4017; // cos(pi/16)\nvar dctSin1 = 799; // sin(pi/16)\nvar dctCos3 = 3406; // cos(3*pi/16)\nvar dctSin3 = 2276; // sin(3*pi/16)\nvar dctCos6 = 1567; // cos(6*pi/16)\nvar dctSin6 = 3784; // sin(6*pi/16)\nvar dctSqrt2 = 5793; // sqrt(2)\nvar dctSqrt1d2 = 2896; // sqrt(2) / 2\n\nfunction buildHuffmanTable(codeLengths, values) {\n  var k = 0;\n  var code = [];\n  var length = 16;\n  while (length > 0 && !codeLengths[length - 1]) {\n    --length;\n  }\n  code.push({\n    children: [],\n    index: 0\n  });\n  var p = code[0];\n  var q;\n  for (var i = 0; i < length; i++) {\n    for (var j = 0; j < codeLengths[i]; j++) {\n      p = code.pop();\n      p.children[p.index] = values[k];\n      while (p.index > 0) {\n        p = code.pop();\n      }\n      p.index++;\n      code.push(p);\n      while (code.length <= i) {\n        code.push(q = {\n          children: [],\n          index: 0\n        });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n      k++;\n    }\n    if (i + 1 < length) {\n      // p here points to last code\n      code.push(q = {\n        children: [],\n        index: 0\n      });\n      p.children[p.index] = q.children;\n      p = q;\n    }\n  }\n  return code[0].children;\n}\nfunction decodeScan(data, initialOffset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {\n  var mcusPerLine = frame.mcusPerLine,\n    progressive = frame.progressive;\n  var startOffset = initialOffset;\n  var offset = initialOffset;\n  var bitsData = 0;\n  var bitsCount = 0;\n  function readBit() {\n    if (bitsCount > 0) {\n      bitsCount--;\n      return bitsData >> bitsCount & 1;\n    }\n    bitsData = data[offset++];\n    if (bitsData === 0xFF) {\n      var nextByte = data[offset++];\n      if (nextByte) {\n        throw new Error(\"unexpected marker: \".concat((bitsData << 8 | nextByte).toString(16)));\n      }\n      // unstuff 0\n    }\n\n    bitsCount = 7;\n    return bitsData >>> 7;\n  }\n  function decodeHuffman(tree) {\n    var node = tree;\n    var bit;\n    while ((bit = readBit()) !== null) {\n      // eslint-disable-line no-cond-assign\n      node = node[bit];\n      if (typeof node === 'number') {\n        return node;\n      }\n      if (typeof node !== 'object') {\n        throw new Error('invalid huffman sequence');\n      }\n    }\n    return null;\n  }\n  function receive(initialLength) {\n    var length = initialLength;\n    var n = 0;\n    while (length > 0) {\n      var bit = readBit();\n      if (bit === null) {\n        return undefined;\n      }\n      n = n << 1 | bit;\n      --length;\n    }\n    return n;\n  }\n  function receiveAndExtend(length) {\n    var n = receive(length);\n    if (n >= 1 << length - 1) {\n      return n;\n    }\n    return n + (-1 << length) + 1;\n  }\n  function decodeBaseline(component, zz) {\n    var t = decodeHuffman(component.huffmanTableDC);\n    var diff = t === 0 ? 0 : receiveAndExtend(t);\n    component.pred += diff;\n    zz[0] = component.pred;\n    var k = 1;\n    while (k < 64) {\n      var rs = decodeHuffman(component.huffmanTableAC);\n      var s = rs & 15;\n      var r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n  }\n  function decodeDCFirst(component, zz) {\n    var t = decodeHuffman(component.huffmanTableDC);\n    var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;\n    component.pred += diff;\n    zz[0] = component.pred;\n  }\n  function decodeDCSuccessive(component, zz) {\n    zz[0] |= readBit() << successive;\n  }\n  var eobrun = 0;\n  function decodeACFirst(component, zz) {\n    if (eobrun > 0) {\n      eobrun--;\n      return;\n    }\n    var k = spectralStart;\n    var e = spectralEnd;\n    while (k <= e) {\n      var rs = decodeHuffman(component.huffmanTableAC);\n      var s = rs & 15;\n      var r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          eobrun = receive(r) + (1 << r) - 1;\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n  }\n  var successiveACState = 0;\n  var successiveACNextValue;\n  function decodeACSuccessive(component, zz) {\n    var k = spectralStart;\n    var e = spectralEnd;\n    var r = 0;\n    while (k <= e) {\n      var z = dctZigZag[k];\n      var direction = zz[z] < 0 ? -1 : 1;\n      switch (successiveACState) {\n        case 0:\n          {\n            // initial state\n            var rs = decodeHuffman(component.huffmanTableAC);\n            var s = rs & 15;\n            r = rs >> 4;\n            if (s === 0) {\n              if (r < 15) {\n                eobrun = receive(r) + (1 << r);\n                successiveACState = 4;\n              } else {\n                r = 16;\n                successiveACState = 1;\n              }\n            } else {\n              if (s !== 1) {\n                throw new Error('invalid ACn encoding');\n              }\n              successiveACNextValue = receiveAndExtend(s);\n              successiveACState = r ? 2 : 3;\n            }\n            continue; // eslint-disable-line no-continue\n          }\n\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            r--;\n            if (r === 0) {\n              successiveACState = successiveACState === 2 ? 3 : 0;\n            }\n          }\n          break;\n        case 3:\n          // set value for a zero item\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4:\n          // eob\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          }\n          break;\n        default:\n          break;\n      }\n      k++;\n    }\n    if (successiveACState === 4) {\n      eobrun--;\n      if (eobrun === 0) {\n        successiveACState = 0;\n      }\n    }\n  }\n  function decodeMcu(component, decodeFunction, mcu, row, col) {\n    var mcuRow = mcu / mcusPerLine | 0;\n    var mcuCol = mcu % mcusPerLine;\n    var blockRow = mcuRow * component.v + row;\n    var blockCol = mcuCol * component.h + col;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n  function decodeBlock(component, decodeFunction, mcu) {\n    var blockRow = mcu / component.blocksPerLine | 0;\n    var blockCol = mcu % component.blocksPerLine;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n  var componentsLength = components.length;\n  var component;\n  var i;\n  var j;\n  var k;\n  var n;\n  var decodeFn;\n  if (progressive) {\n    if (spectralStart === 0) {\n      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n    } else {\n      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n  } else {\n    decodeFn = decodeBaseline;\n  }\n  var mcu = 0;\n  var marker;\n  var mcuExpected;\n  if (componentsLength === 1) {\n    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n  } else {\n    mcuExpected = mcusPerLine * frame.mcusPerColumn;\n  }\n  var usedResetInterval = resetInterval || mcuExpected;\n  while (mcu < mcuExpected) {\n    // reset interval stuff\n    for (i = 0; i < componentsLength; i++) {\n      components[i].pred = 0;\n    }\n    eobrun = 0;\n    if (componentsLength === 1) {\n      component = components[0];\n      for (n = 0; n < usedResetInterval; n++) {\n        decodeBlock(component, decodeFn, mcu);\n        mcu++;\n      }\n    } else {\n      for (n = 0; n < usedResetInterval; n++) {\n        for (i = 0; i < componentsLength; i++) {\n          component = components[i];\n          var _component = component,\n            h = _component.h,\n            v = _component.v;\n          for (j = 0; j < v; j++) {\n            for (k = 0; k < h; k++) {\n              decodeMcu(component, decodeFn, mcu, j, k);\n            }\n          }\n        }\n        mcu++;\n\n        // If we've reached our expected MCU's, stop decoding\n        if (mcu === mcuExpected) {\n          break;\n        }\n      }\n    }\n\n    // find marker\n    bitsCount = 0;\n    marker = data[offset] << 8 | data[offset + 1];\n    if (marker < 0xFF00) {\n      throw new Error('marker was not found');\n    }\n    if (marker >= 0xFFD0 && marker <= 0xFFD7) {\n      // RSTx\n      offset += 2;\n    } else {\n      break;\n    }\n  }\n  return offset - startOffset;\n}\nfunction buildComponentData(frame, component) {\n  var lines = [];\n  var blocksPerLine = component.blocksPerLine,\n    blocksPerColumn = component.blocksPerColumn;\n  var samplesPerLine = blocksPerLine << 3;\n  var R = new Int32Array(64);\n  var r = new Uint8Array(64);\n\n  // A port of poppler's IDCT method which in turn is taken from:\n  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n  //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n  //   988-991.\n  function quantizeAndInverse(zz, dataOut, dataIn) {\n    var qt = component.quantizationTable;\n    var v0;\n    var v1;\n    var v2;\n    var v3;\n    var v4;\n    var v5;\n    var v6;\n    var v7;\n    var t;\n    var p = dataIn;\n    var i;\n\n    // dequant\n    for (i = 0; i < 64; i++) {\n      p[i] = zz[i] * qt[i];\n    }\n\n    // inverse DCT on rows\n    for (i = 0; i < 8; ++i) {\n      var row = 8 * i;\n\n      // check for all-zero AC coefficients\n      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 && p[7 + row] === 0) {\n        t = dctSqrt2 * p[0 + row] + 512 >> 10;\n        p[0 + row] = t;\n        p[1 + row] = t;\n        p[2 + row] = t;\n        p[3 + row] = t;\n        p[4 + row] = t;\n        p[5 + row] = t;\n        p[6 + row] = t;\n        p[7 + row] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = dctSqrt2 * p[0 + row] + 128 >> 8;\n      v1 = dctSqrt2 * p[4 + row] + 128 >> 8;\n      v2 = p[2 + row];\n      v3 = p[6 + row];\n      v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;\n      v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;\n      v5 = p[3 + row] << 4;\n      v6 = p[5 + row] << 4;\n\n      // stage 3\n      t = v0 - v1 + 1 >> 1;\n      v0 = v0 + v1 + 1 >> 1;\n      v1 = t;\n      t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;\n      v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;\n      v3 = t;\n      t = v4 - v6 + 1 >> 1;\n      v4 = v4 + v6 + 1 >> 1;\n      v6 = t;\n      t = v7 + v5 + 1 >> 1;\n      v5 = v7 - v5 + 1 >> 1;\n      v7 = t;\n\n      // stage 2\n      t = v0 - v3 + 1 >> 1;\n      v0 = v0 + v3 + 1 >> 1;\n      v3 = t;\n      t = v1 - v2 + 1 >> 1;\n      v1 = v1 + v2 + 1 >> 1;\n      v2 = t;\n      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n      v7 = t;\n      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n      v6 = t;\n\n      // stage 1\n      p[0 + row] = v0 + v7;\n      p[7 + row] = v0 - v7;\n      p[1 + row] = v1 + v6;\n      p[6 + row] = v1 - v6;\n      p[2 + row] = v2 + v5;\n      p[5 + row] = v2 - v5;\n      p[3 + row] = v3 + v4;\n      p[4 + row] = v3 - v4;\n    }\n\n    // inverse DCT on columns\n    for (i = 0; i < 8; ++i) {\n      var col = i;\n\n      // check for all-zero AC coefficients\n      if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 && p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 && p[7 * 8 + col] === 0) {\n        t = dctSqrt2 * dataIn[i + 0] + 8192 >> 14;\n        p[0 * 8 + col] = t;\n        p[1 * 8 + col] = t;\n        p[2 * 8 + col] = t;\n        p[3 * 8 + col] = t;\n        p[4 * 8 + col] = t;\n        p[5 * 8 + col] = t;\n        p[6 * 8 + col] = t;\n        p[7 * 8 + col] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;\n      v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;\n      v2 = p[2 * 8 + col];\n      v3 = p[6 * 8 + col];\n      v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;\n      v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;\n      v5 = p[3 * 8 + col];\n      v6 = p[5 * 8 + col];\n\n      // stage 3\n      t = v0 - v1 + 1 >> 1;\n      v0 = v0 + v1 + 1 >> 1;\n      v1 = t;\n      t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;\n      v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;\n      v3 = t;\n      t = v4 - v6 + 1 >> 1;\n      v4 = v4 + v6 + 1 >> 1;\n      v6 = t;\n      t = v7 + v5 + 1 >> 1;\n      v5 = v7 - v5 + 1 >> 1;\n      v7 = t;\n\n      // stage 2\n      t = v0 - v3 + 1 >> 1;\n      v0 = v0 + v3 + 1 >> 1;\n      v3 = t;\n      t = v1 - v2 + 1 >> 1;\n      v1 = v1 + v2 + 1 >> 1;\n      v2 = t;\n      t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;\n      v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;\n      v7 = t;\n      t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;\n      v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;\n      v6 = t;\n\n      // stage 1\n      p[0 * 8 + col] = v0 + v7;\n      p[7 * 8 + col] = v0 - v7;\n      p[1 * 8 + col] = v1 + v6;\n      p[6 * 8 + col] = v1 - v6;\n      p[2 * 8 + col] = v2 + v5;\n      p[5 * 8 + col] = v2 - v5;\n      p[3 * 8 + col] = v3 + v4;\n      p[4 * 8 + col] = v3 - v4;\n    }\n\n    // convert to 8-bit integers\n    for (i = 0; i < 64; ++i) {\n      var sample = 128 + (p[i] + 8 >> 4);\n      if (sample < 0) {\n        dataOut[i] = 0;\n      } else if (sample > 0XFF) {\n        dataOut[i] = 0xFF;\n      } else {\n        dataOut[i] = sample;\n      }\n    }\n  }\n  for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n    var scanLine = blockRow << 3;\n    for (var i = 0; i < 8; i++) {\n      lines.push(new Uint8Array(samplesPerLine));\n    }\n    for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n      var offset = 0;\n      var sample = blockCol << 3;\n      for (var j = 0; j < 8; j++) {\n        var line = lines[scanLine + j];\n        for (var _i = 0; _i < 8; _i++) {\n          line[sample + _i] = r[offset++];\n        }\n      }\n    }\n  }\n  return lines;\n}\nvar JpegStreamReader = /*#__PURE__*/function () {\n  function JpegStreamReader() {\n    _classCallCheck(this, JpegStreamReader);\n    this.jfif = null;\n    this.adobe = null;\n    this.quantizationTables = [];\n    this.huffmanTablesAC = [];\n    this.huffmanTablesDC = [];\n    this.resetFrames();\n  }\n  _createClass(JpegStreamReader, [{\n    key: \"resetFrames\",\n    value: function resetFrames() {\n      this.frames = [];\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      var offset = 0;\n      // const { length } = data;\n      function readUint16() {\n        var value = data[offset] << 8 | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n      function prepareComponents(frame) {\n        var maxH = 0;\n        var maxV = 0;\n        var component;\n        var componentId;\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) {\n              maxH = component.h;\n            }\n            if (maxV < component.v) {\n              maxV = component.v;\n            }\n          }\n        }\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocks = [];\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n              for (var j = 0; j < blocksPerLineForMcu; j++) {\n                row.push(new Int32Array(64));\n              }\n              blocks.push(row);\n            }\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n      var fileMarker = readUint16();\n      if (fileMarker !== 0xFFD8) {\n        // SOI (Start of Image)\n        throw new Error('SOI not found');\n      }\n      fileMarker = readUint16();\n      while (fileMarker !== 0xFFD9) {\n        // EOI (End of image)\n        switch (fileMarker) {\n          case 0xFF00:\n            break;\n          case 0xFFE0: // APP0 (Application Specific)\n          case 0xFFE1: // APP1\n          case 0xFFE2: // APP2\n          case 0xFFE3: // APP3\n          case 0xFFE4: // APP4\n          case 0xFFE5: // APP5\n          case 0xFFE6: // APP6\n          case 0xFFE7: // APP7\n          case 0xFFE8: // APP8\n          case 0xFFE9: // APP9\n          case 0xFFEA: // APP10\n          case 0xFFEB: // APP11\n          case 0xFFEC: // APP12\n          case 0xFFED: // APP13\n          case 0xFFEE: // APP14\n          case 0xFFEF: // APP15\n          case 0xFFFE:\n            {\n              // COM (Comment)\n              var appData = readDataBlock();\n              if (fileMarker === 0xFFE0) {\n                if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 && appData[3] === 0x46 && appData[4] === 0) {\n                  // 'JFIF\\x00'\n                  this.jfif = {\n                    version: {\n                      major: appData[5],\n                      minor: appData[6]\n                    },\n                    densityUnits: appData[7],\n                    xDensity: appData[8] << 8 | appData[9],\n                    yDensity: appData[10] << 8 | appData[11],\n                    thumbWidth: appData[12],\n                    thumbHeight: appData[13],\n                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                  };\n                }\n              }\n              // TODO APP1 - Exif\n              if (fileMarker === 0xFFEE) {\n                if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) {\n                  // 'Adobe\\x00'\n                  this.adobe = {\n                    version: appData[6],\n                    flags0: appData[7] << 8 | appData[8],\n                    flags1: appData[9] << 8 | appData[10],\n                    transformCode: appData[11]\n                  };\n                }\n              }\n              break;\n            }\n          case 0xFFDB:\n            {\n              // DQT (Define Quantization Tables)\n              var quantizationTablesLength = readUint16();\n              var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n              while (offset < quantizationTablesEnd) {\n                var quantizationTableSpec = data[offset++];\n                var tableData = new Int32Array(64);\n                if (quantizationTableSpec >> 4 === 0) {\n                  // 8 bit values\n                  for (var j = 0; j < 64; j++) {\n                    var z = dctZigZag[j];\n                    tableData[z] = data[offset++];\n                  }\n                } else if (quantizationTableSpec >> 4 === 1) {\n                  // 16 bit\n                  for (var _j = 0; _j < 64; _j++) {\n                    var _z = dctZigZag[_j];\n                    tableData[_z] = readUint16();\n                  }\n                } else {\n                  throw new Error('DQT: invalid table spec');\n                }\n                this.quantizationTables[quantizationTableSpec & 15] = tableData;\n              }\n              break;\n            }\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n          case 0xFFC2:\n            {\n              // SOF2 (Start of Frame, Progressive DCT)\n              readUint16(); // skip data length\n              var frame = {\n                extended: fileMarker === 0xFFC1,\n                progressive: fileMarker === 0xFFC2,\n                precision: data[offset++],\n                scanLines: readUint16(),\n                samplesPerLine: readUint16(),\n                components: {},\n                componentsOrder: []\n              };\n              var componentsCount = data[offset++];\n              var componentId = void 0;\n              // let maxH = 0;\n              // let maxV = 0;\n              for (var i = 0; i < componentsCount; i++) {\n                componentId = data[offset];\n                var h = data[offset + 1] >> 4;\n                var v = data[offset + 1] & 15;\n                var qId = data[offset + 2];\n                frame.componentsOrder.push(componentId);\n                frame.components[componentId] = {\n                  h: h,\n                  v: v,\n                  quantizationIdx: qId\n                };\n                offset += 3;\n              }\n              prepareComponents(frame);\n              this.frames.push(frame);\n              break;\n            }\n          case 0xFFC4:\n            {\n              // DHT (Define Huffman Tables)\n              var huffmanLength = readUint16();\n              for (var _i2 = 2; _i2 < huffmanLength;) {\n                var huffmanTableSpec = data[offset++];\n                var codeLengths = new Uint8Array(16);\n                var codeLengthSum = 0;\n                for (var _j2 = 0; _j2 < 16; _j2++, offset++) {\n                  codeLengths[_j2] = data[offset];\n                  codeLengthSum += codeLengths[_j2];\n                }\n                var huffmanValues = new Uint8Array(codeLengthSum);\n                for (var _j3 = 0; _j3 < codeLengthSum; _j3++, offset++) {\n                  huffmanValues[_j3] = data[offset];\n                }\n                _i2 += 17 + codeLengthSum;\n                if (huffmanTableSpec >> 4 === 0) {\n                  this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n                } else {\n                  this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n                }\n              }\n              break;\n            }\n          case 0xFFDD:\n            // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n            this.resetInterval = readUint16();\n            break;\n          case 0xFFDA:\n            {\n              // SOS (Start of Scan)\n              readUint16(); // skip length\n              var selectorsCount = data[offset++];\n              var components = [];\n              var _frame = this.frames[0];\n              for (var _i3 = 0; _i3 < selectorsCount; _i3++) {\n                var component = _frame.components[data[offset++]];\n                var tableSpec = data[offset++];\n                component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];\n                component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];\n                components.push(component);\n              }\n              var spectralStart = data[offset++];\n              var spectralEnd = data[offset++];\n              var successiveApproximation = data[offset++];\n              var processed = decodeScan(data, offset, _frame, components, this.resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);\n              offset += processed;\n              break;\n            }\n          case 0xFFFF:\n            // Fill bytes\n            if (data[offset] !== 0xFF) {\n              // Avoid skipping a valid marker.\n              offset--;\n            }\n            break;\n          default:\n            if (data[offset - 3] === 0xFF && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            }\n            throw new Error(\"unknown JPEG marker \".concat(fileMarker.toString(16)));\n        }\n        fileMarker = readUint16();\n      }\n    }\n  }, {\n    key: \"getResult\",\n    value: function getResult() {\n      var frames = this.frames;\n      if (this.frames.length === 0) {\n        throw new Error('no frames were decoded');\n      } else if (this.frames.length > 1) {\n        console.warn('more than one frame is not supported');\n      }\n\n      // set each frame's components quantization table\n      for (var i = 0; i < this.frames.length; i++) {\n        var cp = this.frames[i].components;\n        for (var _i4 = 0, _Object$keys = Object.keys(cp); _i4 < _Object$keys.length; _i4++) {\n          var j = _Object$keys[_i4];\n          cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n      var frame = frames[0];\n      var components = frame.components,\n        componentsOrder = frame.componentsOrder;\n      var outComponents = [];\n      var width = frame.samplesPerLine;\n      var height = frame.scanLines;\n      for (var _i5 = 0; _i5 < componentsOrder.length; _i5++) {\n        var component = components[componentsOrder[_i5]];\n        outComponents.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n      var out = new Uint8Array(width * height * outComponents.length);\n      var oi = 0;\n      for (var y = 0; y < height; ++y) {\n        for (var x = 0; x < width; ++x) {\n          for (var _i6 = 0; _i6 < outComponents.length; ++_i6) {\n            var _component2 = outComponents[_i6];\n            out[oi] = _component2.lines[0 | y * _component2.scaleY][0 | x * _component2.scaleX];\n            ++oi;\n          }\n        }\n      }\n      return out;\n    }\n  }]);\n  return JpegStreamReader;\n}();\nvar JpegDecoder = /*#__PURE__*/function (_BaseDecoder) {\n  _inherits(JpegDecoder, _BaseDecoder);\n  var _super = _createSuper(JpegDecoder);\n  function JpegDecoder(fileDirectory) {\n    var _this;\n    _classCallCheck(this, JpegDecoder);\n    _this = _super.call(this);\n    _this.reader = new JpegStreamReader();\n    if (fileDirectory.JPEGTables) {\n      _this.reader.parse(fileDirectory.JPEGTables);\n    }\n    return _this;\n  }\n  _createClass(JpegDecoder, [{\n    key: \"decodeBlock\",\n    value: function decodeBlock(buffer) {\n      this.reader.resetFrames();\n      this.reader.parse(new Uint8Array(buffer));\n      return this.reader.getResult().buffer;\n    }\n  }]);\n  return JpegDecoder;\n}(BaseDecoder);\nexport { JpegDecoder as default };","map":{"version":3,"names":["BaseDecoder","dctZigZag","Int32Array","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","buildHuffmanTable","codeLengths","values","k","code","length","push","children","index","p","q","i","j","pop","decodeScan","data","initialOffset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","mcusPerLine","progressive","startOffset","offset","bitsData","bitsCount","readBit","nextByte","Error","concat","toString","decodeHuffman","tree","node","bit","receive","initialLength","n","undefined","receiveAndExtend","decodeBaseline","component","zz","t","huffmanTableDC","diff","pred","rs","huffmanTableAC","s","r","z","decodeDCFirst","decodeDCSuccessive","eobrun","decodeACFirst","e","successiveACState","successiveACNextValue","decodeACSuccessive","direction","decodeMcu","decodeFunction","mcu","row","col","mcuRow","mcuCol","blockRow","v","blockCol","h","blocks","decodeBlock","blocksPerLine","componentsLength","decodeFn","marker","mcuExpected","blocksPerColumn","mcusPerColumn","usedResetInterval","_component","buildComponentData","lines","samplesPerLine","R","Uint8Array","quantizeAndInverse","dataOut","dataIn","qt","quantizationTable","v0","v1","v2","v3","v4","v5","v6","v7","sample","scanLine","line","JpegStreamReader","_classCallCheck","jfif","adobe","quantizationTables","huffmanTablesAC","huffmanTablesDC","resetFrames","_createClass","key","value","frames","parse","readUint16","readDataBlock","array","subarray","prepareComponents","maxH","maxV","componentId","hasOwnProperty","Math","ceil","scanLines","blocksPerLineForMcu","blocksPerColumnForMcu","fileMarker","appData","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","flags0","flags1","transformCode","quantizationTablesLength","quantizationTablesEnd","quantizationTableSpec","tableData","extended","precision","componentsOrder","componentsCount","qId","quantizationIdx","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","selectorsCount","tableSpec","successiveApproximation","processed","getResult","console","warn","cp","_i4","_Object$keys","Object","keys","outComponents","width","height","scaleX","scaleY","out","oi","y","x","JpegDecoder","_BaseDecoder","_inherits","_super","_createSuper","fileDirectory","_this","call","reader","JPEGTables","buffer","default"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/geotiff/dist-module/compression/jpeg.js"],"sourcesContent":["import BaseDecoder from './basedecoder.js';\n\n/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nconst dctZigZag = new Int32Array([\n  0,\n  1, 8,\n  16, 9, 2,\n  3, 10, 17, 24,\n  32, 25, 18, 11, 4,\n  5, 12, 19, 26, 33, 40,\n  48, 41, 34, 27, 20, 13, 6,\n  7, 14, 21, 28, 35, 42, 49, 56,\n  57, 50, 43, 36, 29, 22, 15,\n  23, 30, 37, 44, 51, 58,\n  59, 52, 45, 38, 31,\n  39, 46, 53, 60,\n  61, 54, 47,\n  55, 62,\n  63,\n]);\n\nconst dctCos1 = 4017; // cos(pi/16)\nconst dctSin1 = 799; // sin(pi/16)\nconst dctCos3 = 3406; // cos(3*pi/16)\nconst dctSin3 = 2276; // sin(3*pi/16)\nconst dctCos6 = 1567; // cos(6*pi/16)\nconst dctSin6 = 3784; // sin(6*pi/16)\nconst dctSqrt2 = 5793; // sqrt(2)\nconst dctSqrt1d2 = 2896;// sqrt(2) / 2\n\nfunction buildHuffmanTable(codeLengths, values) {\n  let k = 0;\n  const code = [];\n  let length = 16;\n  while (length > 0 && !codeLengths[length - 1]) {\n    --length;\n  }\n  code.push({ children: [], index: 0 });\n\n  let p = code[0];\n  let q;\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < codeLengths[i]; j++) {\n      p = code.pop();\n      p.children[p.index] = values[k];\n      while (p.index > 0) {\n        p = code.pop();\n      }\n      p.index++;\n      code.push(p);\n      while (code.length <= i) {\n        code.push(q = { children: [], index: 0 });\n        p.children[p.index] = q.children;\n        p = q;\n      }\n      k++;\n    }\n    if (i + 1 < length) {\n      // p here points to last code\n      code.push(q = { children: [], index: 0 });\n      p.children[p.index] = q.children;\n      p = q;\n    }\n  }\n  return code[0].children;\n}\n\nfunction decodeScan(data, initialOffset,\n  frame, components, resetInterval,\n  spectralStart, spectralEnd,\n  successivePrev, successive) {\n  const { mcusPerLine, progressive } = frame;\n\n  const startOffset = initialOffset;\n  let offset = initialOffset;\n  let bitsData = 0;\n  let bitsCount = 0;\n  function readBit() {\n    if (bitsCount > 0) {\n      bitsCount--;\n      return (bitsData >> bitsCount) & 1;\n    }\n    bitsData = data[offset++];\n    if (bitsData === 0xFF) {\n      const nextByte = data[offset++];\n      if (nextByte) {\n        throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);\n      }\n      // unstuff 0\n    }\n    bitsCount = 7;\n    return bitsData >>> 7;\n  }\n  function decodeHuffman(tree) {\n    let node = tree;\n    let bit;\n    while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign\n      node = node[bit];\n      if (typeof node === 'number') {\n        return node;\n      }\n      if (typeof node !== 'object') {\n        throw new Error('invalid huffman sequence');\n      }\n    }\n    return null;\n  }\n  function receive(initialLength) {\n    let length = initialLength;\n    let n = 0;\n    while (length > 0) {\n      const bit = readBit();\n      if (bit === null) {\n        return undefined;\n      }\n      n = (n << 1) | bit;\n      --length;\n    }\n    return n;\n  }\n  function receiveAndExtend(length) {\n    const n = receive(length);\n    if (n >= 1 << (length - 1)) {\n      return n;\n    }\n    return n + (-1 << length) + 1;\n  }\n  function decodeBaseline(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : receiveAndExtend(t);\n    component.pred += diff;\n    zz[0] = component.pred;\n    let k = 1;\n    while (k < 64) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n  }\n  function decodeDCFirst(component, zz) {\n    const t = decodeHuffman(component.huffmanTableDC);\n    const diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n    component.pred += diff;\n    zz[0] = component.pred;\n  }\n  function decodeDCSuccessive(component, zz) {\n    zz[0] |= readBit() << successive;\n  }\n  let eobrun = 0;\n  function decodeACFirst(component, zz) {\n    if (eobrun > 0) {\n      eobrun--;\n      return;\n    }\n    let k = spectralStart;\n    const e = spectralEnd;\n    while (k <= e) {\n      const rs = decodeHuffman(component.huffmanTableAC);\n      const s = rs & 15;\n      const r = rs >> 4;\n      if (s === 0) {\n        if (r < 15) {\n          eobrun = receive(r) + (1 << r) - 1;\n          break;\n        }\n        k += 16;\n      } else {\n        k += r;\n        const z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n  }\n  let successiveACState = 0;\n  let successiveACNextValue;\n  function decodeACSuccessive(component, zz) {\n    let k = spectralStart;\n    const e = spectralEnd;\n    let r = 0;\n    while (k <= e) {\n      const z = dctZigZag[k];\n      const direction = zz[z] < 0 ? -1 : 1;\n      switch (successiveACState) {\n        case 0: { // initial state\n          const rs = decodeHuffman(component.huffmanTableAC);\n          const s = rs & 15;\n          r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1) {\n              throw new Error('invalid ACn encoding');\n            }\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue; // eslint-disable-line no-continue\n        }\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            r--;\n            if (r === 0) {\n              successiveACState = successiveACState === 2 ? 3 : 0;\n            }\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          } else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z]) {\n            zz[z] += (readBit() << successive) * direction;\n          }\n          break;\n        default:\n          break;\n      }\n      k++;\n    }\n    if (successiveACState === 4) {\n      eobrun--;\n      if (eobrun === 0) {\n        successiveACState = 0;\n      }\n    }\n  }\n  function decodeMcu(component, decodeFunction, mcu, row, col) {\n    const mcuRow = (mcu / mcusPerLine) | 0;\n    const mcuCol = mcu % mcusPerLine;\n    const blockRow = (mcuRow * component.v) + row;\n    const blockCol = (mcuCol * component.h) + col;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n  function decodeBlock(component, decodeFunction, mcu) {\n    const blockRow = (mcu / component.blocksPerLine) | 0;\n    const blockCol = mcu % component.blocksPerLine;\n    decodeFunction(component, component.blocks[blockRow][blockCol]);\n  }\n\n  const componentsLength = components.length;\n  let component;\n  let i;\n  let j;\n  let k;\n  let n;\n  let decodeFn;\n  if (progressive) {\n    if (spectralStart === 0) {\n      decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n    } else {\n      decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    }\n  } else {\n    decodeFn = decodeBaseline;\n  }\n\n  let mcu = 0;\n  let marker;\n  let mcuExpected;\n  if (componentsLength === 1) {\n    mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n  } else {\n    mcuExpected = mcusPerLine * frame.mcusPerColumn;\n  }\n\n  const usedResetInterval = resetInterval || mcuExpected;\n\n  while (mcu < mcuExpected) {\n    // reset interval stuff\n    for (i = 0; i < componentsLength; i++) {\n      components[i].pred = 0;\n    }\n    eobrun = 0;\n\n    if (componentsLength === 1) {\n      component = components[0];\n      for (n = 0; n < usedResetInterval; n++) {\n        decodeBlock(component, decodeFn, mcu);\n        mcu++;\n      }\n    } else {\n      for (n = 0; n < usedResetInterval; n++) {\n        for (i = 0; i < componentsLength; i++) {\n          component = components[i];\n          const { h, v } = component;\n          for (j = 0; j < v; j++) {\n            for (k = 0; k < h; k++) {\n              decodeMcu(component, decodeFn, mcu, j, k);\n            }\n          }\n        }\n        mcu++;\n\n        // If we've reached our expected MCU's, stop decoding\n        if (mcu === mcuExpected) {\n          break;\n        }\n      }\n    }\n\n    // find marker\n    bitsCount = 0;\n    marker = (data[offset] << 8) | data[offset + 1];\n    if (marker < 0xFF00) {\n      throw new Error('marker was not found');\n    }\n\n    if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n      offset += 2;\n    } else {\n      break;\n    }\n  }\n\n  return offset - startOffset;\n}\n\nfunction buildComponentData(frame, component) {\n  const lines = [];\n  const { blocksPerLine, blocksPerColumn } = component;\n  const samplesPerLine = blocksPerLine << 3;\n  const R = new Int32Array(64);\n  const r = new Uint8Array(64);\n\n  // A port of poppler's IDCT method which in turn is taken from:\n  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n  //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n  //   988-991.\n  function quantizeAndInverse(zz, dataOut, dataIn) {\n    const qt = component.quantizationTable;\n    let v0;\n    let v1;\n    let v2;\n    let v3;\n    let v4;\n    let v5;\n    let v6;\n    let v7;\n    let t;\n    const p = dataIn;\n    let i;\n\n    // dequant\n    for (i = 0; i < 64; i++) {\n      p[i] = zz[i] * qt[i];\n    }\n\n    // inverse DCT on rows\n    for (i = 0; i < 8; ++i) {\n      const row = 8 * i;\n\n      // check for all-zero AC coefficients\n      if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0\n        && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0\n        && p[7 + row] === 0) {\n        t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;\n        p[0 + row] = t;\n        p[1 + row] = t;\n        p[2 + row] = t;\n        p[3 + row] = t;\n        p[4 + row] = t;\n        p[5 + row] = t;\n        p[6 + row] = t;\n        p[7 + row] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;\n      v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;\n      v2 = p[2 + row];\n      v3 = p[6 + row];\n      v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;\n      v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;\n      v5 = p[3 + row] << 4;\n      v6 = p[5 + row] << 4;\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[0 + row] = v0 + v7;\n      p[7 + row] = v0 - v7;\n      p[1 + row] = v1 + v6;\n      p[6 + row] = v1 - v6;\n      p[2 + row] = v2 + v5;\n      p[5 + row] = v2 - v5;\n      p[3 + row] = v3 + v4;\n      p[4 + row] = v3 - v4;\n    }\n\n    // inverse DCT on columns\n    for (i = 0; i < 8; ++i) {\n      const col = i;\n\n      // check for all-zero AC coefficients\n      if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0\n        && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0\n        && p[(7 * 8) + col] === 0) {\n        t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;\n        p[(0 * 8) + col] = t;\n        p[(1 * 8) + col] = t;\n        p[(2 * 8) + col] = t;\n        p[(3 * 8) + col] = t;\n        p[(4 * 8) + col] = t;\n        p[(5 * 8) + col] = t;\n        p[(6 * 8) + col] = t;\n        p[(7 * 8) + col] = t;\n        continue; // eslint-disable-line no-continue\n      }\n\n      // stage 4\n      v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;\n      v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;\n      v2 = p[(2 * 8) + col];\n      v3 = p[(6 * 8) + col];\n      v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;\n      v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;\n      v5 = p[(3 * 8) + col];\n      v6 = p[(5 * 8) + col];\n\n      // stage 3\n      t = (v0 - v1 + 1) >> 1;\n      v0 = (v0 + v1 + 1) >> 1;\n      v1 = t;\n      t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;\n      v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;\n      v3 = t;\n      t = (v4 - v6 + 1) >> 1;\n      v4 = (v4 + v6 + 1) >> 1;\n      v6 = t;\n      t = (v7 + v5 + 1) >> 1;\n      v5 = (v7 - v5 + 1) >> 1;\n      v7 = t;\n\n      // stage 2\n      t = (v0 - v3 + 1) >> 1;\n      v0 = (v0 + v3 + 1) >> 1;\n      v3 = t;\n      t = (v1 - v2 + 1) >> 1;\n      v1 = (v1 + v2 + 1) >> 1;\n      v2 = t;\n      t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n      v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n      v7 = t;\n      t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n      v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n      v6 = t;\n\n      // stage 1\n      p[(0 * 8) + col] = v0 + v7;\n      p[(7 * 8) + col] = v0 - v7;\n      p[(1 * 8) + col] = v1 + v6;\n      p[(6 * 8) + col] = v1 - v6;\n      p[(2 * 8) + col] = v2 + v5;\n      p[(5 * 8) + col] = v2 - v5;\n      p[(3 * 8) + col] = v3 + v4;\n      p[(4 * 8) + col] = v3 - v4;\n    }\n\n    // convert to 8-bit integers\n    for (i = 0; i < 64; ++i) {\n      const sample = 128 + ((p[i] + 8) >> 4);\n      if (sample < 0) {\n        dataOut[i] = 0;\n      } else if (sample > 0XFF) {\n        dataOut[i] = 0xFF;\n      } else {\n        dataOut[i] = sample;\n      }\n    }\n  }\n\n  for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n    const scanLine = blockRow << 3;\n    for (let i = 0; i < 8; i++) {\n      lines.push(new Uint8Array(samplesPerLine));\n    }\n    for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n      quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n      let offset = 0;\n      const sample = blockCol << 3;\n      for (let j = 0; j < 8; j++) {\n        const line = lines[scanLine + j];\n        for (let i = 0; i < 8; i++) {\n          line[sample + i] = r[offset++];\n        }\n      }\n    }\n  }\n  return lines;\n}\n\nclass JpegStreamReader {\n  constructor() {\n    this.jfif = null;\n    this.adobe = null;\n\n    this.quantizationTables = [];\n    this.huffmanTablesAC = [];\n    this.huffmanTablesDC = [];\n    this.resetFrames();\n  }\n\n  resetFrames() {\n    this.frames = [];\n  }\n\n  parse(data) {\n    let offset = 0;\n    // const { length } = data;\n    function readUint16() {\n      const value = (data[offset] << 8) | data[offset + 1];\n      offset += 2;\n      return value;\n    }\n    function readDataBlock() {\n      const length = readUint16();\n      const array = data.subarray(offset, offset + length - 2);\n      offset += array.length;\n      return array;\n    }\n    function prepareComponents(frame) {\n      let maxH = 0;\n      let maxV = 0;\n      let component;\n      let componentId;\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          if (maxH < component.h) {\n            maxH = component.h;\n          }\n          if (maxV < component.v) {\n            maxV = component.v;\n          }\n        }\n      }\n      const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n      const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n      for (componentId in frame.components) {\n        if (frame.components.hasOwnProperty(componentId)) {\n          component = frame.components[componentId];\n          const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n          const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n          const blocksPerLineForMcu = mcusPerLine * component.h;\n          const blocksPerColumnForMcu = mcusPerColumn * component.v;\n          const blocks = [];\n          for (let i = 0; i < blocksPerColumnForMcu; i++) {\n            const row = [];\n            for (let j = 0; j < blocksPerLineForMcu; j++) {\n              row.push(new Int32Array(64));\n            }\n            blocks.push(row);\n          }\n          component.blocksPerLine = blocksPerLine;\n          component.blocksPerColumn = blocksPerColumn;\n          component.blocks = blocks;\n        }\n      }\n      frame.maxH = maxH;\n      frame.maxV = maxV;\n      frame.mcusPerLine = mcusPerLine;\n      frame.mcusPerColumn = mcusPerColumn;\n    }\n\n    let fileMarker = readUint16();\n    if (fileMarker !== 0xFFD8) { // SOI (Start of Image)\n      throw new Error('SOI not found');\n    }\n\n    fileMarker = readUint16();\n    while (fileMarker !== 0xFFD9) { // EOI (End of image)\n      switch (fileMarker) {\n        case 0xFF00: break;\n        case 0xFFE0: // APP0 (Application Specific)\n        case 0xFFE1: // APP1\n        case 0xFFE2: // APP2\n        case 0xFFE3: // APP3\n        case 0xFFE4: // APP4\n        case 0xFFE5: // APP5\n        case 0xFFE6: // APP6\n        case 0xFFE7: // APP7\n        case 0xFFE8: // APP8\n        case 0xFFE9: // APP9\n        case 0xFFEA: // APP10\n        case 0xFFEB: // APP11\n        case 0xFFEC: // APP12\n        case 0xFFED: // APP13\n        case 0xFFEE: // APP14\n        case 0xFFEF: // APP15\n        case 0xFFFE: { // COM (Comment)\n          const appData = readDataBlock();\n\n          if (fileMarker === 0xFFE0) {\n            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49\n              && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n              this.jfif = {\n                version: { major: appData[5], minor: appData[6] },\n                densityUnits: appData[7],\n                xDensity: (appData[8] << 8) | appData[9],\n                yDensity: (appData[10] << 8) | appData[11],\n                thumbWidth: appData[12],\n                thumbHeight: appData[13],\n                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),\n              };\n            }\n          }\n          // TODO APP1 - Exif\n          if (fileMarker === 0xFFEE) {\n            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F\n              && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n              this.adobe = {\n                version: appData[6],\n                flags0: (appData[7] << 8) | appData[8],\n                flags1: (appData[9] << 8) | appData[10],\n                transformCode: appData[11],\n              };\n            }\n          }\n          break;\n        }\n\n        case 0xFFDB: { // DQT (Define Quantization Tables)\n          const quantizationTablesLength = readUint16();\n          const quantizationTablesEnd = quantizationTablesLength + offset - 2;\n          while (offset < quantizationTablesEnd) {\n            const quantizationTableSpec = data[offset++];\n            const tableData = new Int32Array(64);\n            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = data[offset++];\n              }\n            } else if ((quantizationTableSpec >> 4) === 1) { // 16 bit\n              for (let j = 0; j < 64; j++) {\n                const z = dctZigZag[j];\n                tableData[z] = readUint16();\n              }\n            } else {\n              throw new Error('DQT: invalid table spec');\n            }\n            this.quantizationTables[quantizationTableSpec & 15] = tableData;\n          }\n          break;\n        }\n\n        case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n        case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n        case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)\n          readUint16(); // skip data length\n          const frame = {\n            extended: (fileMarker === 0xFFC1),\n            progressive: (fileMarker === 0xFFC2),\n            precision: data[offset++],\n            scanLines: readUint16(),\n            samplesPerLine: readUint16(),\n            components: {},\n            componentsOrder: [],\n          };\n\n          const componentsCount = data[offset++];\n          let componentId;\n          // let maxH = 0;\n          // let maxV = 0;\n          for (let i = 0; i < componentsCount; i++) {\n            componentId = data[offset];\n            const h = data[offset + 1] >> 4;\n            const v = data[offset + 1] & 15;\n            const qId = data[offset + 2];\n            frame.componentsOrder.push(componentId);\n            frame.components[componentId] = {\n              h,\n              v,\n              quantizationIdx: qId,\n            };\n            offset += 3;\n          }\n          prepareComponents(frame);\n          this.frames.push(frame);\n          break;\n        }\n\n        case 0xFFC4: { // DHT (Define Huffman Tables)\n          const huffmanLength = readUint16();\n          for (let i = 2; i < huffmanLength;) {\n            const huffmanTableSpec = data[offset++];\n            const codeLengths = new Uint8Array(16);\n            let codeLengthSum = 0;\n            for (let j = 0; j < 16; j++, offset++) {\n              codeLengths[j] = data[offset];\n              codeLengthSum += codeLengths[j];\n            }\n            const huffmanValues = new Uint8Array(codeLengthSum);\n            for (let j = 0; j < codeLengthSum; j++, offset++) {\n              huffmanValues[j] = data[offset];\n            }\n            i += 17 + codeLengthSum;\n\n            if ((huffmanTableSpec >> 4) === 0) {\n              this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            } else {\n              this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(\n                codeLengths, huffmanValues,\n              );\n            }\n          }\n          break;\n        }\n\n        case 0xFFDD: // DRI (Define Restart Interval)\n          readUint16(); // skip data length\n          this.resetInterval = readUint16();\n          break;\n\n        case 0xFFDA: { // SOS (Start of Scan)\n          readUint16(); // skip length\n          const selectorsCount = data[offset++];\n          const components = [];\n          const frame = this.frames[0];\n          for (let i = 0; i < selectorsCount; i++) {\n            const component = frame.components[data[offset++]];\n            const tableSpec = data[offset++];\n            component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];\n            component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];\n            components.push(component);\n          }\n          const spectralStart = data[offset++];\n          const spectralEnd = data[offset++];\n          const successiveApproximation = data[offset++];\n          const processed = decodeScan(data, offset,\n            frame, components, this.resetInterval,\n            spectralStart, spectralEnd,\n            successiveApproximation >> 4, successiveApproximation & 15);\n          offset += processed;\n          break;\n        }\n\n        case 0xFFFF: // Fill bytes\n          if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n            offset--;\n          }\n          break;\n\n        default:\n          if (data[offset - 3] === 0xFF\n            && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n            // could be incorrect encoding -- last 0xFF byte of the previous\n            // block was eaten by the encoder\n            offset -= 3;\n            break;\n          }\n          throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);\n      }\n      fileMarker = readUint16();\n    }\n  }\n\n  getResult() {\n    const { frames } = this;\n    if (this.frames.length === 0) {\n      throw new Error('no frames were decoded');\n    } else if (this.frames.length > 1) {\n      console.warn('more than one frame is not supported');\n    }\n\n    // set each frame's components quantization table\n    for (let i = 0; i < this.frames.length; i++) {\n      const cp = this.frames[i].components;\n      for (const j of Object.keys(cp)) {\n        cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];\n        delete cp[j].quantizationIdx;\n      }\n    }\n\n    const frame = frames[0];\n    const { components, componentsOrder } = frame;\n    const outComponents = [];\n    const width = frame.samplesPerLine;\n    const height = frame.scanLines;\n\n    for (let i = 0; i < componentsOrder.length; i++) {\n      const component = components[componentsOrder[i]];\n      outComponents.push({\n        lines: buildComponentData(frame, component),\n        scaleX: component.h / frame.maxH,\n        scaleY: component.v / frame.maxV,\n      });\n    }\n\n    const out = new Uint8Array(width * height * outComponents.length);\n    let oi = 0;\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        for (let i = 0; i < outComponents.length; ++i) {\n          const component = outComponents[i];\n          out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];\n          ++oi;\n        }\n      }\n    }\n    return out;\n  }\n}\n\nexport default class JpegDecoder extends BaseDecoder {\n  constructor(fileDirectory) {\n    super();\n    this.reader = new JpegStreamReader();\n    if (fileDirectory.JPEGTables) {\n      this.reader.parse(fileDirectory.JPEGTables);\n    }\n  }\n\n  decodeBlock(buffer) {\n    this.reader.resetFrames();\n    this.reader.parse(new Uint8Array(buffer));\n    return this.reader.getResult().buffer;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}