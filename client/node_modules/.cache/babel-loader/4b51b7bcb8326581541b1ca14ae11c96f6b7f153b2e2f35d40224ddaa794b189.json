{"ast":null,"code":"// algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nimport { NativeArrayBuffer, NativeFloat32Array, NativeUint32Array } from \"./primordials.mjs\";\nconst buffer = new NativeArrayBuffer(4);\nconst floatView = new NativeFloat32Array(buffer);\nconst uint32View = new NativeUint32Array(buffer);\nconst baseTable = new NativeUint32Array(512);\nconst shiftTable = new NativeUint32Array(512);\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -27) {\n    baseTable[i] = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i] = 24;\n    shiftTable[i | 0x100] = 24;\n\n    // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i] = 0x0400 >> -e - 14;\n    baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;\n    shiftTable[i] = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n    // normal number\n  } else if (e <= 15) {\n    baseTable[i] = e + 15 << 10;\n    baseTable[i | 0x100] = e + 15 << 10 | 0x8000;\n    shiftTable[i] = 13;\n    shiftTable[i | 0x100] = 13;\n\n    // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i] = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i] = 24;\n    shiftTable[i | 0x100] = 24;\n\n    // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i] = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i] = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n *\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n  floatView[0] = /** @type {any} */num;\n  const f = uint32View[0];\n  const e = f >> 23 & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\nconst mantissaTable = new NativeUint32Array(2048);\nconst exponentTable = new NativeUint32Array(64);\nconst offsetTable = new NativeUint32Array(64);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + (i - 1024 << 13);\n}\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + (i - 32 << 23);\n}\nexponentTable[63] = 0xc7800000;\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n *\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n  const m = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];\n  return floatView[0];\n}","map":{"version":3,"names":["NativeArrayBuffer","NativeFloat32Array","NativeUint32Array","buffer","floatView","uint32View","baseTable","shiftTable","i","e","roundToFloat16Bits","num","f","mantissaTable","exponentTable","offsetTable","m","convertToNumber","float16bits"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/@petamoriken/float16/src/_util/converter.mjs"],"sourcesContent":["// algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nimport {\n  NativeArrayBuffer,\n  NativeFloat32Array,\n  NativeUint32Array,\n} from \"./primordials.mjs\";\n\nconst buffer = new NativeArrayBuffer(4);\nconst floatView = new NativeFloat32Array(buffer);\nconst uint32View = new NativeUint32Array(buffer);\n\nconst baseTable = new NativeUint32Array(512);\nconst shiftTable = new NativeUint32Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -27) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n *\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n  floatView[0] = /** @type {any} */ (num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new NativeUint32Array(2048);\nconst exponentTable = new NativeUint32Array(64);\nconst offsetTable = new NativeUint32Array(64);\n\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13;    // zero pad mantissa bits\n  let e = 0;          // zero exponent\n\n  // normalized\n  while((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000;  // decrement exponent\n  }\n\n  m &= ~0x00800000;   // clear leading 1 bit\n  e += 0x38800000;    // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n *\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n  const m = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 0x3ff)] + exponentTable[m];\n  return floatView[0];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}