{"ast":null,"code":"import _slicedToArray from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  var s = 0;\n  for (var i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1:\n      // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2:\n      // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3:\n      // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  var view = new DataView(inBuffer);\n  var outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;\n  var samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;\n  var outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  var bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n  if (format === 1) {\n    // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    var pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    var bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = bitsPerLine + 7 & ~7;\n    }\n    for (var y = 0; y < tileHeight; ++y) {\n      var lineBitOffset = y * bitsPerLine;\n      for (var x = 0; x < tileWidth; ++x) {\n        var pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;\n        for (var i = 0; i < samplesToTransfer; ++i) {\n          var bitOffset = pixelBitOffset + i * bitsPerSample;\n          var outIndex = (y * tileWidth + x) * samplesToTransfer + i;\n          var byteOffset = Math.floor(bitOffset / 8);\n          var innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            var raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);\n            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;\n          } else {\n            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) {// floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nvar GeoTIFFImage = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  function GeoTIFFImage(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    _classCallCheck(this, GeoTIFFImage);\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    var planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  _createClass(GeoTIFFImage, [{\n    key: \"getFileDirectory\",\n    value: function getFileDirectory() {\n      return this.fileDirectory;\n    }\n\n    /**\n     * Returns the associated parsed geo keys.\n     * @returns {Object} the parsed geo keys\n     */\n  }, {\n    key: \"getGeoKeys\",\n    value: function getGeoKeys() {\n      return this.geoKeys;\n    }\n\n    /**\n     * Returns the width of the image.\n     * @returns {Number} the width of the image\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.fileDirectory.ImageWidth;\n    }\n\n    /**\n     * Returns the height of the image.\n     * @returns {Number} the height of the image\n     */\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.fileDirectory.ImageLength;\n    }\n\n    /**\n     * Returns the number of samples per pixel.\n     * @returns {Number} the number of samples per pixel\n     */\n  }, {\n    key: \"getSamplesPerPixel\",\n    value: function getSamplesPerPixel() {\n      return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;\n    }\n\n    /**\n     * Returns the width of each tile.\n     * @returns {Number} the width of each tile\n     */\n  }, {\n    key: \"getTileWidth\",\n    value: function getTileWidth() {\n      return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n    }\n\n    /**\n     * Returns the height of each tile.\n     * @returns {Number} the height of each tile\n     */\n  }, {\n    key: \"getTileHeight\",\n    value: function getTileHeight() {\n      if (this.isTiled) {\n        return this.fileDirectory.TileLength;\n      }\n      if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n        return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n      }\n      return this.getHeight();\n    }\n  }, {\n    key: \"getBlockWidth\",\n    value: function getBlockWidth() {\n      return this.getTileWidth();\n    }\n  }, {\n    key: \"getBlockHeight\",\n    value: function getBlockHeight(y) {\n      if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n        return this.getTileHeight();\n      } else {\n        return this.getHeight() - y * this.getTileHeight();\n      }\n    }\n\n    /**\n     * Calculates the number of bytes for each pixel across all samples. Only full\n     * bytes are supported, an exception is thrown when this is not the case.\n     * @returns {Number} the bytes per pixel\n     */\n  }, {\n    key: \"getBytesPerPixel\",\n    value: function getBytesPerPixel() {\n      var bytes = 0;\n      for (var i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n        bytes += this.getSampleByteSize(i);\n      }\n      return bytes;\n    }\n  }, {\n    key: \"getSampleByteSize\",\n    value: function getSampleByteSize(i) {\n      if (i >= this.fileDirectory.BitsPerSample.length) {\n        throw new RangeError(\"Sample index \".concat(i, \" is out of range.\"));\n      }\n      return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n    }\n  }, {\n    key: \"getReaderForSample\",\n    value: function getReaderForSample(sampleIndex) {\n      var format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n      var bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n      switch (format) {\n        case 1:\n          // unsigned integer data\n          if (bitsPerSample <= 8) {\n            return DataView.prototype.getUint8;\n          } else if (bitsPerSample <= 16) {\n            return DataView.prototype.getUint16;\n          } else if (bitsPerSample <= 32) {\n            return DataView.prototype.getUint32;\n          }\n          break;\n        case 2:\n          // twos complement signed integer data\n          if (bitsPerSample <= 8) {\n            return DataView.prototype.getInt8;\n          } else if (bitsPerSample <= 16) {\n            return DataView.prototype.getInt16;\n          } else if (bitsPerSample <= 32) {\n            return DataView.prototype.getInt32;\n          }\n          break;\n        case 3:\n          switch (bitsPerSample) {\n            case 16:\n              return function (offset, littleEndian) {\n                return getFloat16(this, offset, littleEndian);\n              };\n            case 32:\n              return DataView.prototype.getFloat32;\n            case 64:\n              return DataView.prototype.getFloat64;\n            default:\n              break;\n          }\n          break;\n        default:\n          break;\n      }\n      throw Error('Unsupported data format/bitsPerSample');\n    }\n  }, {\n    key: \"getSampleFormat\",\n    value: function getSampleFormat() {\n      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    }\n  }, {\n    key: \"getBitsPerSample\",\n    value: function getBitsPerSample() {\n      var sampleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.fileDirectory.BitsPerSample[sampleIndex];\n    }\n  }, {\n    key: \"getArrayForSample\",\n    value: function getArrayForSample(sampleIndex, size) {\n      var format = this.getSampleFormat(sampleIndex);\n      var bitsPerSample = this.getBitsPerSample(sampleIndex);\n      return arrayForType(format, bitsPerSample, size);\n    }\n\n    /**\n     * Returns the decoded strip or tile.\n     * @param {Number} x the strip or tile x-offset\n     * @param {Number} y the tile y-offset (0 for stripped images)\n     * @param {Number} sample the sample to get for separated samples\n     * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n     *                               to be aborted\n     * @returns {Promise.<ArrayBuffer>}\n     */\n  }, {\n    key: \"getTileOrStrip\",\n    value: function () {\n      var _getTileOrStrip = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(x, y, sample, poolOrDecoder, signal) {\n        var _this = this;\n        var numTilesPerRow, numTilesPerCol, index, tiles, offset, byteCount, slice, request;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n              numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n              tiles = this.tiles;\n              if (this.planarConfiguration === 1) {\n                index = y * numTilesPerRow + x;\n              } else if (this.planarConfiguration === 2) {\n                index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;\n              }\n              if (this.isTiled) {\n                offset = this.fileDirectory.TileOffsets[index];\n                byteCount = this.fileDirectory.TileByteCounts[index];\n              } else {\n                offset = this.fileDirectory.StripOffsets[index];\n                byteCount = this.fileDirectory.StripByteCounts[index];\n              }\n              _context2.next = 7;\n              return this.source.fetch([{\n                offset: offset,\n                length: byteCount\n              }], signal);\n            case 7:\n              slice = _context2.sent[0];\n              if (tiles === null || !tiles[index]) {\n                // resolve each request by potentially applying array normalization\n                request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                  var data, sampleFormat, bitsPerSample;\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return poolOrDecoder.decode(_this.fileDirectory, slice);\n                      case 2:\n                        data = _context.sent;\n                        sampleFormat = _this.getSampleFormat();\n                        bitsPerSample = _this.getBitsPerSample();\n                        if (needsNormalization(sampleFormat, bitsPerSample)) {\n                          data = normalizeArray(data, sampleFormat, _this.planarConfiguration, _this.getSamplesPerPixel(), bitsPerSample, _this.getTileWidth(), _this.getBlockHeight(y));\n                        }\n                        return _context.abrupt(\"return\", data);\n                      case 7:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }, _callee);\n                }))();\n\n                // set the cache\n                if (tiles !== null) {\n                  tiles[index] = request;\n                }\n              } else {\n                // get from the cache\n                request = tiles[index];\n              }\n\n              // cache the tile request\n              _context2.t0 = x;\n              _context2.t1 = y;\n              _context2.t2 = sample;\n              _context2.next = 14;\n              return request;\n            case 14:\n              _context2.t3 = _context2.sent;\n              return _context2.abrupt(\"return\", {\n                x: _context2.t0,\n                y: _context2.t1,\n                sample: _context2.t2,\n                data: _context2.t3\n              });\n            case 16:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getTileOrStrip(_x, _x2, _x3, _x4, _x5) {\n        return _getTileOrStrip.apply(this, arguments);\n      }\n      return getTileOrStrip;\n    }()\n    /**\n     * Internal read function.\n     * @private\n     * @param {Array} imageWindow The image window in pixel coordinates\n     * @param {Array} samples The selected samples (0-based indices)\n     * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n     * @param {Boolean} interleave Whether or not to write in an interleaved manner\n     * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n     * @param {number} width the width of window to be read into\n     * @param {number} height the height of window to be read into\n     * @param {number} resampleMethod the resampling method to be used when interpolating\n     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n     *                               to be aborted\n     * @returns {Promise<ReadRasterResult>}\n     */\n  }, {\n    key: \"_readRaster\",\n    value: function () {\n      var _readRaster2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {\n        var _this2 = this;\n        var tileWidth, tileHeight, imageWidth, imageHeight, minXTile, maxXTile, minYTile, maxYTile, windowWidth, bytesPerPixel, srcSampleOffsets, sampleReaders, i, promises, littleEndian, yTile, xTile, _loop, sampleIndex, resampled;\n        return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              tileWidth = this.getTileWidth();\n              tileHeight = this.getTileHeight();\n              imageWidth = this.getWidth();\n              imageHeight = this.getHeight();\n              minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n              maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));\n              minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n              maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));\n              windowWidth = imageWindow[2] - imageWindow[0];\n              bytesPerPixel = this.getBytesPerPixel();\n              srcSampleOffsets = [];\n              sampleReaders = [];\n              for (i = 0; i < samples.length; ++i) {\n                if (this.planarConfiguration === 1) {\n                  srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n                } else {\n                  srcSampleOffsets.push(0);\n                }\n                sampleReaders.push(this.getReaderForSample(samples[i]));\n              }\n              promises = [];\n              littleEndian = this.littleEndian;\n              yTile = minYTile;\n            case 16:\n              if (!(yTile < maxYTile)) {\n                _context4.next = 32;\n                break;\n              }\n              xTile = minXTile;\n            case 18:\n              if (!(xTile < maxXTile)) {\n                _context4.next = 29;\n                break;\n              }\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                var si, sample, promise;\n                return _regeneratorRuntime().wrap(function _loop$(_context3) {\n                  while (1) switch (_context3.prev = _context3.next) {\n                    case 0:\n                      si = sampleIndex;\n                      sample = samples[sampleIndex];\n                      if (_this2.planarConfiguration === 2) {\n                        bytesPerPixel = _this2.getSampleByteSize(sampleIndex);\n                      }\n                      promise = _this2.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal).then(function (tile) {\n                        var buffer = tile.data;\n                        var dataView = new DataView(buffer);\n                        var blockHeight = _this2.getBlockHeight(tile.y);\n                        var firstLine = tile.y * tileHeight;\n                        var firstCol = tile.x * tileWidth;\n                        var lastLine = firstLine + blockHeight;\n                        var lastCol = (tile.x + 1) * tileWidth;\n                        var reader = sampleReaders[si];\n                        var ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n                        var xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n                        for (var y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n                          for (var x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                            var pixelOffset = (y * tileWidth + x) * bytesPerPixel;\n                            var value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);\n                            var windowCoordinate = void 0;\n                            if (interleave) {\n                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;\n                              valueArrays[windowCoordinate] = value;\n                            } else {\n                              windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];\n                              valueArrays[si][windowCoordinate] = value;\n                            }\n                          }\n                        }\n                      });\n                      promises.push(promise);\n                    case 5:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }, _loop);\n              });\n              sampleIndex = 0;\n            case 21:\n              if (!(sampleIndex < samples.length)) {\n                _context4.next = 26;\n                break;\n              }\n              return _context4.delegateYield(_loop(), \"t0\", 23);\n            case 23:\n              ++sampleIndex;\n              _context4.next = 21;\n              break;\n            case 26:\n              ++xTile;\n              _context4.next = 18;\n              break;\n            case 29:\n              ++yTile;\n              _context4.next = 16;\n              break;\n            case 32:\n              _context4.next = 34;\n              return Promise.all(promises);\n            case 34:\n              if (!(width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height)) {\n                _context4.next = 39;\n                break;\n              }\n              if (interleave) {\n                resampled = resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);\n              } else {\n                resampled = resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);\n              }\n              resampled.width = width;\n              resampled.height = height;\n              return _context4.abrupt(\"return\", resampled);\n            case 39:\n              valueArrays.width = width || imageWindow[2] - imageWindow[0];\n              valueArrays.height = height || imageWindow[3] - imageWindow[1];\n              return _context4.abrupt(\"return\", valueArrays);\n            case 42:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee3, this);\n      }));\n      function _readRaster(_x6, _x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14) {\n        return _readRaster2.apply(this, arguments);\n      }\n      return _readRaster;\n    }()\n    /**\n     * Reads raster data from the image. This function reads all selected samples\n     * into separate arrays of the correct type for that sample or into a single\n     * combined array when `interleave` is set. When provided, only a subset\n     * of the raster is read for each sample.\n     *\n     * @param {ReadRasterOptions} [options={}] optional parameters\n     * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n     */\n  }, {\n    key: \"readRasters\",\n    value: function () {\n      var _readRasters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _ref2,\n          wnd,\n          _ref2$samples,\n          samples,\n          interleave,\n          _ref2$pool,\n          pool,\n          width,\n          height,\n          resampleMethod,\n          fillValue,\n          signal,\n          imageWindow,\n          imageWindowWidth,\n          imageWindowHeight,\n          numPixels,\n          samplesPerPixel,\n          i,\n          _i,\n          valueArrays,\n          format,\n          bitsPerSample,\n          _i2,\n          valueArray,\n          poolOrDecoder,\n          result,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _ref2 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, wnd = _ref2.window, _ref2$samples = _ref2.samples, samples = _ref2$samples === void 0 ? [] : _ref2$samples, interleave = _ref2.interleave, _ref2$pool = _ref2.pool, pool = _ref2$pool === void 0 ? null : _ref2$pool, width = _ref2.width, height = _ref2.height, resampleMethod = _ref2.resampleMethod, fillValue = _ref2.fillValue, signal = _ref2.signal;\n              imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n              if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {\n                _context5.next = 4;\n                break;\n              }\n              throw new Error('Invalid subsets');\n            case 4:\n              imageWindowWidth = imageWindow[2] - imageWindow[0];\n              imageWindowHeight = imageWindow[3] - imageWindow[1];\n              numPixels = imageWindowWidth * imageWindowHeight;\n              samplesPerPixel = this.getSamplesPerPixel();\n              if (!(!samples || !samples.length)) {\n                _context5.next = 12;\n                break;\n              }\n              for (i = 0; i < samplesPerPixel; ++i) {\n                samples.push(i);\n              }\n              _context5.next = 19;\n              break;\n            case 12:\n              _i = 0;\n            case 13:\n              if (!(_i < samples.length)) {\n                _context5.next = 19;\n                break;\n              }\n              if (!(samples[_i] >= samplesPerPixel)) {\n                _context5.next = 16;\n                break;\n              }\n              return _context5.abrupt(\"return\", Promise.reject(new RangeError(\"Invalid sample index '\".concat(samples[_i], \"'.\"))));\n            case 16:\n              ++_i;\n              _context5.next = 13;\n              break;\n            case 19:\n              if (interleave) {\n                format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n                bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n                valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n                if (fillValue) {\n                  valueArrays.fill(fillValue);\n                }\n              } else {\n                valueArrays = [];\n                for (_i2 = 0; _i2 < samples.length; ++_i2) {\n                  valueArray = this.getArrayForSample(samples[_i2], numPixels);\n                  if (Array.isArray(fillValue) && _i2 < fillValue.length) {\n                    valueArray.fill(fillValue[_i2]);\n                  } else if (fillValue && !Array.isArray(fillValue)) {\n                    valueArray.fill(fillValue);\n                  }\n                  valueArrays.push(valueArray);\n                }\n              }\n              _context5.t0 = pool;\n              if (_context5.t0) {\n                _context5.next = 25;\n                break;\n              }\n              _context5.next = 24;\n              return getDecoder(this.fileDirectory);\n            case 24:\n              _context5.t0 = _context5.sent;\n            case 25:\n              poolOrDecoder = _context5.t0;\n              _context5.next = 28;\n              return this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);\n            case 28:\n              result = _context5.sent;\n              return _context5.abrupt(\"return\", result);\n            case 30:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this);\n      }));\n      function readRasters() {\n        return _readRasters.apply(this, arguments);\n      }\n      return readRasters;\n    }()\n    /**\n     * Reads raster data from the image as RGB. The result is always an\n     * interleaved typed array.\n     * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n     * When no other method is applicable, the first sample is used to produce a\n     * grayscale image.\n     * When provided, only a subset of the raster is read for each sample.\n     *\n     * @param {Object} [options] optional parameters\n     * @param {Array<number>} [options.window] the subset to read data from in pixels.\n     * @param {boolean} [options.interleave=true] whether the data shall be read\n     *                                             in one single array or separate\n     *                                             arrays.\n     * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n     * @param {number} [options.width] The desired width of the output. When the width is no the\n     *                                 same as the images, resampling will be performed.\n     * @param {number} [options.height] The desired height of the output. When the width is no the\n     *                                  same as the images, resampling will be performed.\n     * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n     * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n     * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n     *                                       to be aborted\n     * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n     */\n  }, {\n    key: \"readRGB\",\n    value: function () {\n      var _readRGB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _ref3,\n          window,\n          _ref3$interleave,\n          interleave,\n          _ref3$pool,\n          pool,\n          width,\n          height,\n          resampleMethod,\n          _ref3$enableAlpha,\n          enableAlpha,\n          signal,\n          imageWindow,\n          pi,\n          s,\n          i,\n          samples,\n          subOptions,\n          fileDirectory,\n          raster,\n          max,\n          data,\n          red,\n          green,\n          blue,\n          _i3,\n          j,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _ref3 = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {}, window = _ref3.window, _ref3$interleave = _ref3.interleave, interleave = _ref3$interleave === void 0 ? true : _ref3$interleave, _ref3$pool = _ref3.pool, pool = _ref3$pool === void 0 ? null : _ref3$pool, width = _ref3.width, height = _ref3.height, resampleMethod = _ref3.resampleMethod, _ref3$enableAlpha = _ref3.enableAlpha, enableAlpha = _ref3$enableAlpha === void 0 ? false : _ref3$enableAlpha, signal = _ref3.signal;\n              imageWindow = window || [0, 0, this.getWidth(), this.getHeight()]; // check parameters\n              if (!(imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3])) {\n                _context6.next = 4;\n                break;\n              }\n              throw new Error('Invalid subsets');\n            case 4:\n              pi = this.fileDirectory.PhotometricInterpretation;\n              if (!(pi === photometricInterpretations.RGB)) {\n                _context6.next = 9;\n                break;\n              }\n              s = [0, 1, 2];\n              if (!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) && enableAlpha) {\n                s = [];\n                for (i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n                  s.push(i);\n                }\n              }\n              return _context6.abrupt(\"return\", this.readRasters({\n                window: window,\n                interleave: interleave,\n                samples: s,\n                pool: pool,\n                width: width,\n                height: height,\n                resampleMethod: resampleMethod,\n                signal: signal\n              }));\n            case 9:\n              _context6.t0 = pi;\n              _context6.next = _context6.t0 === photometricInterpretations.WhiteIsZero ? 12 : _context6.t0 === photometricInterpretations.BlackIsZero ? 12 : _context6.t0 === photometricInterpretations.Palette ? 12 : _context6.t0 === photometricInterpretations.CMYK ? 14 : _context6.t0 === photometricInterpretations.YCbCr ? 16 : _context6.t0 === photometricInterpretations.CIELab ? 16 : 18;\n              break;\n            case 12:\n              samples = [0];\n              return _context6.abrupt(\"break\", 19);\n            case 14:\n              samples = [0, 1, 2, 3];\n              return _context6.abrupt(\"break\", 19);\n            case 16:\n              samples = [0, 1, 2];\n              return _context6.abrupt(\"break\", 19);\n            case 18:\n              throw new Error('Invalid or unsupported photometric interpretation.');\n            case 19:\n              subOptions = {\n                window: imageWindow,\n                interleave: true,\n                samples: samples,\n                pool: pool,\n                width: width,\n                height: height,\n                resampleMethod: resampleMethod,\n                signal: signal\n              };\n              fileDirectory = this.fileDirectory;\n              _context6.next = 23;\n              return this.readRasters(subOptions);\n            case 23:\n              raster = _context6.sent;\n              max = Math.pow(2, this.fileDirectory.BitsPerSample[0]);\n              _context6.t1 = pi;\n              _context6.next = _context6.t1 === photometricInterpretations.WhiteIsZero ? 28 : _context6.t1 === photometricInterpretations.BlackIsZero ? 30 : _context6.t1 === photometricInterpretations.Palette ? 32 : _context6.t1 === photometricInterpretations.CMYK ? 34 : _context6.t1 === photometricInterpretations.YCbCr ? 36 : _context6.t1 === photometricInterpretations.CIELab ? 38 : 40;\n              break;\n            case 28:\n              data = fromWhiteIsZero(raster, max);\n              return _context6.abrupt(\"break\", 41);\n            case 30:\n              data = fromBlackIsZero(raster, max);\n              return _context6.abrupt(\"break\", 41);\n            case 32:\n              data = fromPalette(raster, fileDirectory.ColorMap);\n              return _context6.abrupt(\"break\", 41);\n            case 34:\n              data = fromCMYK(raster);\n              return _context6.abrupt(\"break\", 41);\n            case 36:\n              data = fromYCbCr(raster);\n              return _context6.abrupt(\"break\", 41);\n            case 38:\n              data = fromCIELab(raster);\n              return _context6.abrupt(\"break\", 41);\n            case 40:\n              throw new Error('Unsupported photometric interpretation.');\n            case 41:\n              // if non-interleaved data is requested, we must split the channels\n              // into their respective arrays\n              if (!interleave) {\n                red = new Uint8Array(data.length / 3);\n                green = new Uint8Array(data.length / 3);\n                blue = new Uint8Array(data.length / 3);\n                for (_i3 = 0, j = 0; _i3 < data.length; _i3 += 3, ++j) {\n                  red[j] = data[_i3];\n                  green[j] = data[_i3 + 1];\n                  blue[j] = data[_i3 + 2];\n                }\n                data = [red, green, blue];\n              }\n              data.width = raster.width;\n              data.height = raster.height;\n              return _context6.abrupt(\"return\", data);\n            case 45:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this);\n      }));\n      function readRGB() {\n        return _readRGB.apply(this, arguments);\n      }\n      return readRGB;\n    }()\n    /**\n     * Returns an array of tiepoints.\n     * @returns {Object[]}\n     */\n  }, {\n    key: \"getTiePoints\",\n    value: function getTiePoints() {\n      if (!this.fileDirectory.ModelTiepoint) {\n        return [];\n      }\n      var tiePoints = [];\n      for (var i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n        tiePoints.push({\n          i: this.fileDirectory.ModelTiepoint[i],\n          j: this.fileDirectory.ModelTiepoint[i + 1],\n          k: this.fileDirectory.ModelTiepoint[i + 2],\n          x: this.fileDirectory.ModelTiepoint[i + 3],\n          y: this.fileDirectory.ModelTiepoint[i + 4],\n          z: this.fileDirectory.ModelTiepoint[i + 5]\n        });\n      }\n      return tiePoints;\n    }\n\n    /**\n     * Returns the parsed GDAL metadata items.\n     *\n     * If sample is passed to null, dataset-level metadata will be returned.\n     * Otherwise only metadata specific to the provided sample will be returned.\n     *\n     * @param {number} [sample=null] The sample index.\n     * @returns {Object}\n     */\n  }, {\n    key: \"getGDALMetadata\",\n    value: function getGDALMetadata() {\n      var sample = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var metadata = {};\n      if (!this.fileDirectory.GDAL_METADATA) {\n        return null;\n      }\n      var string = this.fileDirectory.GDAL_METADATA;\n      var items = findTagsByName(string, 'Item');\n      if (sample === null) {\n        items = items.filter(function (item) {\n          return getAttribute(item, 'sample') === undefined;\n        });\n      } else {\n        items = items.filter(function (item) {\n          return Number(getAttribute(item, 'sample')) === sample;\n        });\n      }\n      for (var i = 0; i < items.length; ++i) {\n        var item = items[i];\n        metadata[getAttribute(item, 'name')] = item.inner;\n      }\n      return metadata;\n    }\n\n    /**\n     * Returns the GDAL nodata value\n     * @returns {number|null}\n     */\n  }, {\n    key: \"getGDALNoData\",\n    value: function getGDALNoData() {\n      if (!this.fileDirectory.GDAL_NODATA) {\n        return null;\n      }\n      var string = this.fileDirectory.GDAL_NODATA;\n      return Number(string.substring(0, string.length - 1));\n    }\n\n    /**\n     * Returns the image origin as a XYZ-vector. When the image has no affine\n     * transformation, then an exception is thrown.\n     * @returns {Array<number>} The origin as a vector\n     */\n  }, {\n    key: \"getOrigin\",\n    value: function getOrigin() {\n      var tiePoints = this.fileDirectory.ModelTiepoint;\n      var modelTransformation = this.fileDirectory.ModelTransformation;\n      if (tiePoints && tiePoints.length === 6) {\n        return [tiePoints[3], tiePoints[4], tiePoints[5]];\n      }\n      if (modelTransformation) {\n        return [modelTransformation[3], modelTransformation[7], modelTransformation[11]];\n      }\n      throw new Error('The image does not have an affine transformation.');\n    }\n\n    /**\n     * Returns the image resolution as a XYZ-vector. When the image has no affine\n     * transformation, then an exception is thrown.\n     * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n     *                                             in cases when the current image does not have the\n     *                                             required tags on its own.\n     * @returns {Array<number>} The resolution as a vector\n     */\n  }, {\n    key: \"getResolution\",\n    value: function getResolution() {\n      var referenceImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var modelPixelScale = this.fileDirectory.ModelPixelScale;\n      var modelTransformation = this.fileDirectory.ModelTransformation;\n      if (modelPixelScale) {\n        return [modelPixelScale[0], -modelPixelScale[1], modelPixelScale[2]];\n      }\n      if (modelTransformation) {\n        return [modelTransformation[0], modelTransformation[5], modelTransformation[10]];\n      }\n      if (referenceImage) {\n        var _referenceImage$getRe = referenceImage.getResolution(),\n          _referenceImage$getRe2 = _slicedToArray(_referenceImage$getRe, 3),\n          refResX = _referenceImage$getRe2[0],\n          refResY = _referenceImage$getRe2[1],\n          refResZ = _referenceImage$getRe2[2];\n        return [refResX * referenceImage.getWidth() / this.getWidth(), refResY * referenceImage.getHeight() / this.getHeight(), refResZ * referenceImage.getWidth() / this.getWidth()];\n      }\n      throw new Error('The image does not have an affine transformation.');\n    }\n\n    /**\n     * Returns whether or not the pixels of the image depict an area (or point).\n     * @returns {Boolean} Whether the pixels are a point\n     */\n  }, {\n    key: \"pixelIsArea\",\n    value: function pixelIsArea() {\n      return this.geoKeys.GTRasterTypeGeoKey === 1;\n    }\n\n    /**\n     * Returns the image bounding box as an array of 4 values: min-x, min-y,\n     * max-x and max-y. When the image has no affine transformation, then an\n     * exception is thrown.\n     * @returns {Array<number>} The bounding box\n     */\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox() {\n      var origin = this.getOrigin();\n      var resolution = this.getResolution();\n      var x1 = origin[0];\n      var y1 = origin[1];\n      var x2 = x1 + resolution[0] * this.getWidth();\n      var y2 = y1 + resolution[1] * this.getHeight();\n      return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n    }\n  }]);\n  return GeoTIFFImage;\n}();\nexport default GeoTIFFImage;","map":{"version":3,"names":["getFloat16","getAttribute","findTagsByName","photometricInterpretations","ExtraSamplesValues","fromWhiteIsZero","fromBlackIsZero","fromPalette","fromCMYK","fromYCbCr","fromCIELab","getDecoder","resample","resampleInterleaved","sum","array","start","end","s","i","arrayForType","format","bitsPerSample","size","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","Error","needsNormalization","normalizeArray","inBuffer","planarConfiguration","samplesPerPixel","tileWidth","tileHeight","view","DataView","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","y","lineBitOffset","x","pixelBitOffset","bitOffset","outIndex","byteOffset","Math","floor","innerBitOffset","getUint8","getUint16","raw","getUint32","buffer","GeoTIFFImage","fileDirectory","geoKeys","dataView","littleEndian","cache","source","_classCallCheck","tiles","isTiled","StripOffsets","PlanarConfiguration","_createClass","key","value","getFileDirectory","getGeoKeys","getWidth","ImageWidth","getHeight","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","min","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","length","getSampleByteSize","RangeError","concat","ceil","getReaderForSample","sampleIndex","SampleFormat","prototype","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","arguments","undefined","getBitsPerSample","getArrayForSample","_getTileOrStrip","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","sample","poolOrDecoder","signal","_this","numTilesPerRow","numTilesPerCol","index","byteCount","slice","request","wrap","_callee2$","_context2","prev","next","TileOffsets","TileByteCounts","StripByteCounts","fetch","sent","_callee","data","sampleFormat","_callee$","_context","decode","abrupt","stop","t0","t1","t2","t3","getTileOrStrip","_x","_x2","_x3","_x4","_x5","apply","_readRaster2","_callee3","imageWindow","samples","valueArrays","interleave","width","height","resampleMethod","_this2","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","_loop","resampled","_callee3$","_context4","max","push","si","promise","_loop$","_context3","then","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","call","windowCoordinate","delegateYield","Promise","all","_readRaster","_x6","_x7","_x8","_x9","_x10","_x11","_x12","_x13","_x14","_readRasters","_callee4","_ref2","wnd","_ref2$samples","_ref2$pool","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","_i","_i2","valueArray","result","_args5","_callee4$","_context5","window","reject","fill","Array","isArray","readRasters","_readRGB","_callee5","_ref3","_ref3$interleave","_ref3$pool","_ref3$enableAlpha","enableAlpha","pi","subOptions","raster","red","green","blue","_i3","j","_args6","_callee5$","_context6","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","pow","ColorMap","readRGB","getTiePoints","ModelTiepoint","tiePoints","k","z","getGDALMetadata","metadata","GDAL_METADATA","string","items","filter","item","Number","inner","getGDALNoData","GDAL_NODATA","substring","getOrigin","modelTransformation","ModelTransformation","getResolution","referenceImage","modelPixelScale","ModelPixelScale","_referenceImage$getRe","_referenceImage$getRe2","_slicedToArray","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","getBoundingBox","origin","resolution","x1","y1","x2","y2"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/geotiff/dist-module/geotiffimage.js"],"sourcesContent":["/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal).then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}