{"ast":null,"code":"import _regeneratorRuntime from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _inherits from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _createClass from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\nimport { makeRemoteSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.SBYTE:\n    case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT:\n    case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG:\n    case fieldTypes.SLONG:\n    case fieldTypes.FLOAT:\n    case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL:\n    case fieldTypes.SRATIONAL:\n    case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8:\n    case fieldTypes.SLONG8:\n    case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(\"Invalid field type: \".concat(fieldType));\n  }\n}\nfunction parseGeoKeyDirectory(fileDirectory) {\n  var rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n  var geoKeyDirectory = {};\n  for (var i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    var key = geoKeyNames[rawGeoKeyDirectory[i]];\n    var location = rawGeoKeyDirectory[i + 1] ? fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;\n    var count = rawGeoKeyDirectory[i + 2];\n    var offset = rawGeoKeyDirectory[i + 3];\n    var value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(\"Could not get value of geoKey '\".concat(key, \"'.\"));\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\nfunction getValues(dataSlice, fieldType, count, offset) {\n  var values = null;\n  var readMethod = null;\n  var fieldTypeLength = getFieldTypeLength(fieldType);\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count);\n      readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count);\n      readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count);\n      readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count);\n      readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG:\n    case fieldTypes.IFD:\n      values = new Uint32Array(count);\n      readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count);\n      readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8:\n    case fieldTypes.IFD8:\n      values = new Array(count);\n      readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count);\n      readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2);\n      readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2);\n      readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count);\n      readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count);\n      readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(\"Invalid field type: \".concat(fieldType));\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (var i = 0; i < count; ++i) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n    }\n  } else {\n    // RATIONAL or SRATIONAL\n    for (var _i = 0; _i < count; _i += 2) {\n      values[_i] = readMethod.call(dataSlice, offset + _i * fieldTypeLength);\n      values[_i + 1] = readMethod.call(dataSlice, offset + (_i * fieldTypeLength + 4));\n    }\n  }\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nvar ImageFileDirectory = /*#__PURE__*/_createClass(function ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n  _classCallCheck(this, ImageFileDirectory);\n  this.fileDirectory = fileDirectory;\n  this.geoKeyDirectory = geoKeyDirectory;\n  this.nextIFDByteOffset = nextIFDByteOffset;\n});\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nvar GeoTIFFImageIndexError = /*#__PURE__*/function (_Error) {\n  _inherits(GeoTIFFImageIndexError, _Error);\n  var _super = _createSuper(GeoTIFFImageIndexError);\n  function GeoTIFFImageIndexError(index) {\n    var _this;\n    _classCallCheck(this, GeoTIFFImageIndexError);\n    _this = _super.call(this, \"No image at index \".concat(index));\n    _this.index = index;\n    return _this;\n  }\n  return _createClass(GeoTIFFImageIndexError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar GeoTIFFBase = /*#__PURE__*/function () {\n  function GeoTIFFBase() {\n    _classCallCheck(this, GeoTIFFBase);\n  }\n  _createClass(GeoTIFFBase, [{\n    key: \"readRasters\",\n    value:\n    /**\n     * (experimental) Reads raster data from the best fitting image. This function uses\n     * the image with the lowest resolution that is still a higher resolution than the\n     * requested resolution.\n     * When specified, the `bbox` option is translated to the `window` option and the\n     * `resX` and `resY` to `width` and `height` respectively.\n     * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n     * image is called and the result returned.\n     * @see GeoTIFFImage.readRasters\n     * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n     * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n     */\n    function () {\n      var _readRasters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var options,\n          imageWindow,\n          width,\n          height,\n          resX,\n          resY,\n          bbox,\n          firstImage,\n          usedImage,\n          imageCount,\n          imgBBox,\n          _firstImage$getOrigin,\n          _firstImage$getOrigin2,\n          oX,\n          oY,\n          _firstImage$getResolu,\n          _firstImage$getResolu2,\n          rX,\n          rY,\n          usedBBox,\n          allImages,\n          i,\n          image,\n          _image$fileDirectory,\n          subfileType,\n          newSubfileType,\n          _i2,\n          _image,\n          imgResX,\n          imgResY,\n          wnd,\n          _firstImage$getOrigin3,\n          _firstImage$getOrigin4,\n          _oX,\n          _oY,\n          _usedImage$getResolut,\n          _usedImage$getResolut2,\n          imageResX,\n          imageResY,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n              imageWindow = options.window, width = options.width, height = options.height;\n              resX = options.resX, resY = options.resY, bbox = options.bbox;\n              _context.next = 5;\n              return this.getImage();\n            case 5:\n              firstImage = _context.sent;\n              usedImage = firstImage;\n              _context.next = 9;\n              return this.getImageCount();\n            case 9:\n              imageCount = _context.sent;\n              imgBBox = firstImage.getBoundingBox();\n              if (!(imageWindow && bbox)) {\n                _context.next = 13;\n                break;\n              }\n              throw new Error('Both \"bbox\" and \"window\" passed.');\n            case 13:\n              if (!(width || height)) {\n                _context.next = 24;\n                break;\n              }\n              // if we have an image window (pixel coordinates), transform it to a BBox\n              // using the origin/resolution of the first image.\n              if (imageWindow) {\n                _firstImage$getOrigin = firstImage.getOrigin(), _firstImage$getOrigin2 = _slicedToArray(_firstImage$getOrigin, 2), oX = _firstImage$getOrigin2[0], oY = _firstImage$getOrigin2[1];\n                _firstImage$getResolu = firstImage.getResolution(), _firstImage$getResolu2 = _slicedToArray(_firstImage$getResolu, 2), rX = _firstImage$getResolu2[0], rY = _firstImage$getResolu2[1];\n                bbox = [oX + imageWindow[0] * rX, oY + imageWindow[1] * rY, oX + imageWindow[2] * rX, oY + imageWindow[3] * rY];\n              }\n\n              // if we have a bbox (or calculated one)\n              usedBBox = bbox || imgBBox;\n              if (!width) {\n                _context.next = 20;\n                break;\n              }\n              if (!resX) {\n                _context.next = 19;\n                break;\n              }\n              throw new Error('Both width and resX passed');\n            case 19:\n              resX = (usedBBox[2] - usedBBox[0]) / width;\n            case 20:\n              if (!height) {\n                _context.next = 24;\n                break;\n              }\n              if (!resY) {\n                _context.next = 23;\n                break;\n              }\n              throw new Error('Both width and resY passed');\n            case 23:\n              resY = (usedBBox[3] - usedBBox[1]) / height;\n            case 24:\n              if (!(resX || resY)) {\n                _context.next = 48;\n                break;\n              }\n              allImages = [];\n              i = 0;\n            case 27:\n              if (!(i < imageCount)) {\n                _context.next = 36;\n                break;\n              }\n              _context.next = 30;\n              return this.getImage(i);\n            case 30:\n              image = _context.sent;\n              _image$fileDirectory = image.fileDirectory, subfileType = _image$fileDirectory.SubfileType, newSubfileType = _image$fileDirectory.NewSubfileType;\n              if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n                allImages.push(image);\n              }\n            case 33:\n              ++i;\n              _context.next = 27;\n              break;\n            case 36:\n              allImages.sort(function (a, b) {\n                return a.getWidth() - b.getWidth();\n              });\n              _i2 = 0;\n            case 38:\n              if (!(_i2 < allImages.length)) {\n                _context.next = 48;\n                break;\n              }\n              _image = allImages[_i2];\n              imgResX = (imgBBox[2] - imgBBox[0]) / _image.getWidth();\n              imgResY = (imgBBox[3] - imgBBox[1]) / _image.getHeight();\n              usedImage = _image;\n              if (!(resX && resX > imgResX || resY && resY > imgResY)) {\n                _context.next = 45;\n                break;\n              }\n              return _context.abrupt(\"break\", 48);\n            case 45:\n              ++_i2;\n              _context.next = 38;\n              break;\n            case 48:\n              wnd = imageWindow;\n              if (bbox) {\n                _firstImage$getOrigin3 = firstImage.getOrigin(), _firstImage$getOrigin4 = _slicedToArray(_firstImage$getOrigin3, 2), _oX = _firstImage$getOrigin4[0], _oY = _firstImage$getOrigin4[1];\n                _usedImage$getResolut = usedImage.getResolution(firstImage), _usedImage$getResolut2 = _slicedToArray(_usedImage$getResolut, 2), imageResX = _usedImage$getResolut2[0], imageResY = _usedImage$getResolut2[1];\n                wnd = [Math.round((bbox[0] - _oX) / imageResX), Math.round((bbox[1] - _oY) / imageResY), Math.round((bbox[2] - _oX) / imageResX), Math.round((bbox[3] - _oY) / imageResY)];\n                wnd = [Math.min(wnd[0], wnd[2]), Math.min(wnd[1], wnd[3]), Math.max(wnd[0], wnd[2]), Math.max(wnd[1], wnd[3])];\n              }\n              return _context.abrupt(\"return\", usedImage.readRasters(_objectSpread(_objectSpread({}, options), {}, {\n                window: wnd\n              })));\n            case 51:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function readRasters() {\n        return _readRasters.apply(this, arguments);\n      }\n      return readRasters;\n    }()\n  }]);\n  return GeoTIFFBase;\n}();\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nvar GeoTIFF = /*#__PURE__*/function (_GeoTIFFBase) {\n  _inherits(GeoTIFF, _GeoTIFFBase);\n  var _super2 = _createSuper(GeoTIFF);\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  function GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset) {\n    var _this2;\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    _classCallCheck(this, GeoTIFF);\n    _this2 = _super2.call(this);\n    _this2.source = source;\n    _this2.littleEndian = littleEndian;\n    _this2.bigTiff = bigTiff;\n    _this2.firstIFDOffset = firstIFDOffset;\n    _this2.cache = options.cache || false;\n    _this2.ifdRequests = [];\n    _this2.ghostValues = null;\n    return _this2;\n  }\n  _createClass(GeoTIFF, [{\n    key: \"getSlice\",\n    value: function () {\n      var _getSlice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(offset, size) {\n        var fallbackSize;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              fallbackSize = this.bigTiff ? 4048 : 1024;\n              _context2.t0 = DataSlice;\n              _context2.next = 4;\n              return this.source.fetch([{\n                offset: offset,\n                length: typeof size !== 'undefined' ? size : fallbackSize\n              }]);\n            case 4:\n              _context2.t1 = _context2.sent[0];\n              _context2.t2 = offset;\n              _context2.t3 = this.littleEndian;\n              _context2.t4 = this.bigTiff;\n              return _context2.abrupt(\"return\", new _context2.t0(_context2.t1, _context2.t2, _context2.t3, _context2.t4));\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getSlice(_x, _x2) {\n        return _getSlice.apply(this, arguments);\n      }\n      return getSlice;\n    }()\n    /**\n     * Instructs to parse an image file directory at the given file offset.\n     * As there is no way to ensure that a location is indeed the start of an IFD,\n     * this function must be called with caution (e.g only using the IFD offsets from\n     * the headers or other IFDs).\n     * @param {number} offset the offset to parse the IFD at\n     * @returns {Promise<ImageFileDirectory>} the parsed IFD\n     */\n  }, {\n    key: \"parseFileDirectoryAt\",\n    value: function () {\n      var _parseFileDirectoryAt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(offset) {\n        var entrySize, offsetSize, dataSlice, numDirEntries, byteSize, fileDirectory, i, entryCount, fieldTag, fieldType, typeCount, fieldValues, value, fieldTypeLength, valueOffset, actualOffset, length, fieldDataSlice, geoKeyDirectory, nextIFDByteOffset;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              entrySize = this.bigTiff ? 20 : 12;\n              offsetSize = this.bigTiff ? 8 : 2;\n              _context3.next = 4;\n              return this.getSlice(offset);\n            case 4:\n              dataSlice = _context3.sent;\n              numDirEntries = this.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset); // if the slice does not cover the whole IFD, request a bigger slice, where the\n              // whole IFD fits: num of entries + n x tag length + offset to next IFD\n              byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);\n              if (dataSlice.covers(offset, byteSize)) {\n                _context3.next = 11;\n                break;\n              }\n              _context3.next = 10;\n              return this.getSlice(offset, byteSize);\n            case 10:\n              dataSlice = _context3.sent;\n            case 11:\n              fileDirectory = {}; // loop over the IFD and create a file directory object\n              i = offset + (this.bigTiff ? 8 : 2);\n              entryCount = 0;\n            case 14:\n              if (!(entryCount < numDirEntries)) {\n                _context3.next = 41;\n                break;\n              }\n              fieldTag = dataSlice.readUint16(i);\n              fieldType = dataSlice.readUint16(i + 2);\n              typeCount = this.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);\n              fieldValues = void 0;\n              value = void 0;\n              fieldTypeLength = getFieldTypeLength(fieldType);\n              valueOffset = i + (this.bigTiff ? 12 : 8); // check whether the value is directly encoded in the tag or refers to a\n              // different external byte range\n              if (!(fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4))) {\n                _context3.next = 26;\n                break;\n              }\n              fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n              _context3.next = 36;\n              break;\n            case 26:\n              // resolve the reference to the actual byte range\n              actualOffset = dataSlice.readOffset(valueOffset);\n              length = getFieldTypeLength(fieldType) * typeCount; // check, whether we actually cover the referenced byte range; if not,\n              // request a new slice of bytes to read from it\n              if (!dataSlice.covers(actualOffset, length)) {\n                _context3.next = 32;\n                break;\n              }\n              fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n              _context3.next = 36;\n              break;\n            case 32:\n              _context3.next = 34;\n              return this.getSlice(actualOffset, length);\n            case 34:\n              fieldDataSlice = _context3.sent;\n              fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n            case 36:\n              // unpack single values from the array\n              if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n                value = fieldValues[0];\n              } else {\n                value = fieldValues;\n              }\n\n              // write the tags value to the file directly\n              fileDirectory[fieldTagNames[fieldTag]] = value;\n            case 38:\n              i += entrySize, ++entryCount;\n              _context3.next = 14;\n              break;\n            case 41:\n              geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n              nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);\n              return _context3.abrupt(\"return\", new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset));\n            case 44:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function parseFileDirectoryAt(_x3) {\n        return _parseFileDirectoryAt.apply(this, arguments);\n      }\n      return parseFileDirectoryAt;\n    }()\n  }, {\n    key: \"requestIFD\",\n    value: function () {\n      var _requestIFD = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(index) {\n        var _this3 = this;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!this.ifdRequests[index]) {\n                _context5.next = 4;\n                break;\n              }\n              return _context5.abrupt(\"return\", this.ifdRequests[index]);\n            case 4:\n              if (!(index === 0)) {\n                _context5.next = 9;\n                break;\n              }\n              // special case for index 0\n              this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n              return _context5.abrupt(\"return\", this.ifdRequests[index]);\n            case 9:\n              if (this.ifdRequests[index - 1]) {\n                _context5.next = 19;\n                break;\n              }\n              _context5.prev = 10;\n              this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n              _context5.next = 19;\n              break;\n            case 14:\n              _context5.prev = 14;\n              _context5.t0 = _context5[\"catch\"](10);\n              if (!(_context5.t0 instanceof GeoTIFFImageIndexError)) {\n                _context5.next = 18;\n                break;\n              }\n              throw new GeoTIFFImageIndexError(index);\n            case 18:\n              throw _context5.t0;\n            case 19:\n              // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n              // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n              this.ifdRequests[index] = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                var previousIfd;\n                return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return _this3.ifdRequests[index - 1];\n                    case 2:\n                      previousIfd = _context4.sent;\n                      if (!(previousIfd.nextIFDByteOffset === 0)) {\n                        _context4.next = 5;\n                        break;\n                      }\n                      throw new GeoTIFFImageIndexError(index);\n                    case 5:\n                      return _context4.abrupt(\"return\", _this3.parseFileDirectoryAt(previousIfd.nextIFDByteOffset));\n                    case 6:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _callee4);\n              }))();\n              return _context5.abrupt(\"return\", this.ifdRequests[index]);\n            case 21:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[10, 14]]);\n      }));\n      function requestIFD(_x4) {\n        return _requestIFD.apply(this, arguments);\n      }\n      return requestIFD;\n    }()\n    /**\n     * Get the n-th internal subfile of an image. By default, the first is returned.\n     *\n     * @param {number} [index=0] the index of the image to return.\n     * @returns {Promise<GeoTIFFImage>} the image at the given index\n     */\n  }, {\n    key: \"getImage\",\n    value: function () {\n      var _getImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var index,\n          ifd,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              index = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : 0;\n              _context6.next = 3;\n              return this.requestIFD(index);\n            case 3:\n              ifd = _context6.sent;\n              return _context6.abrupt(\"return\", new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source));\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getImage() {\n        return _getImage.apply(this, arguments);\n      }\n      return getImage;\n    }()\n    /**\n     * Returns the count of the internal subfiles.\n     *\n     * @returns {Promise<number>} the number of internal subfile images\n     */\n  }, {\n    key: \"getImageCount\",\n    value: function () {\n      var _getImageCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var index, hasNext;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              index = 0; // loop until we run out of IFDs\n              hasNext = true;\n            case 2:\n              if (!hasNext) {\n                _context7.next = 18;\n                break;\n              }\n              _context7.prev = 3;\n              _context7.next = 6;\n              return this.requestIFD(index);\n            case 6:\n              ++index;\n              _context7.next = 16;\n              break;\n            case 9:\n              _context7.prev = 9;\n              _context7.t0 = _context7[\"catch\"](3);\n              if (!(_context7.t0 instanceof GeoTIFFImageIndexError)) {\n                _context7.next = 15;\n                break;\n              }\n              hasNext = false;\n              _context7.next = 16;\n              break;\n            case 15:\n              throw _context7.t0;\n            case 16:\n              _context7.next = 2;\n              break;\n            case 18:\n              return _context7.abrupt(\"return\", index);\n            case 19:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[3, 9]]);\n      }));\n      function getImageCount() {\n        return _getImageCount.apply(this, arguments);\n      }\n      return getImageCount;\n    }()\n    /**\n     * Get the values of the COG ghost area as a parsed map.\n     * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n     * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n     */\n  }, {\n    key: \"getGhostValues\",\n    value: function () {\n      var _getGhostValues = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _this4 = this;\n        var offset, detectionString, heuristicAreaSize, slice, valuesString, firstLine, metadataSize, fullString;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              offset = this.bigTiff ? 16 : 8;\n              if (!this.ghostValues) {\n                _context8.next = 3;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.ghostValues);\n            case 3:\n              detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n              heuristicAreaSize = detectionString.length + 100;\n              _context8.next = 7;\n              return this.getSlice(offset, heuristicAreaSize);\n            case 7:\n              slice = _context8.sent;\n              if (!(detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset))) {\n                _context8.next = 19;\n                break;\n              }\n              valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n              firstLine = valuesString.split('\\n')[0];\n              metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n              if (!(metadataSize > heuristicAreaSize)) {\n                _context8.next = 16;\n                break;\n              }\n              _context8.next = 15;\n              return this.getSlice(offset, metadataSize);\n            case 15:\n              slice = _context8.sent;\n            case 16:\n              fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n              this.ghostValues = {};\n              fullString.split('\\n').filter(function (line) {\n                return line.length > 0;\n              }).map(function (line) {\n                return line.split('=');\n              }).forEach(function (_ref2) {\n                var _ref3 = _slicedToArray(_ref2, 2),\n                  key = _ref3[0],\n                  value = _ref3[1];\n                _this4.ghostValues[key] = value;\n              });\n            case 19:\n              return _context8.abrupt(\"return\", this.ghostValues);\n            case 20:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function getGhostValues() {\n        return _getGhostValues.apply(this, arguments);\n      }\n      return getGhostValues;\n    }()\n    /**\n     * Parse a (Geo)TIFF file from the given source.\n     *\n     * @param {*} source The source of data to parse from.\n     * @param {GeoTIFFOptions} [options] Additional options.\n     * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n     *                               to be aborted\n     */\n  }, {\n    key: \"close\",\n    value:\n    /**\n     * Closes the underlying file buffer\n     * N.B. After the GeoTIFF has been completely processed it needs\n     * to be closed but only if it has been constructed from a file.\n     */\n    function close() {\n      if (typeof this.source.close === 'function') {\n        return this.source.close();\n      }\n      return false;\n    }\n  }], [{\n    key: \"fromSource\",\n    value: function () {\n      var _fromSource = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(source, options, signal) {\n        var headerData, dataView, BOM, littleEndian, magicNumber, bigTiff, offsetByteSize, firstIFDOffset;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return source.fetch([{\n                offset: 0,\n                length: 1024\n              }], signal);\n            case 2:\n              headerData = _context9.sent[0];\n              dataView = new DataView64(headerData);\n              BOM = dataView.getUint16(0, 0);\n              if (!(BOM === 0x4949)) {\n                _context9.next = 9;\n                break;\n              }\n              littleEndian = true;\n              _context9.next = 14;\n              break;\n            case 9:\n              if (!(BOM === 0x4D4D)) {\n                _context9.next = 13;\n                break;\n              }\n              littleEndian = false;\n              _context9.next = 14;\n              break;\n            case 13:\n              throw new TypeError('Invalid byte order value.');\n            case 14:\n              magicNumber = dataView.getUint16(2, littleEndian);\n              if (!(magicNumber === 42)) {\n                _context9.next = 19;\n                break;\n              }\n              bigTiff = false;\n              _context9.next = 27;\n              break;\n            case 19:\n              if (!(magicNumber === 43)) {\n                _context9.next = 26;\n                break;\n              }\n              bigTiff = true;\n              offsetByteSize = dataView.getUint16(4, littleEndian);\n              if (!(offsetByteSize !== 8)) {\n                _context9.next = 24;\n                break;\n              }\n              throw new Error('Unsupported offset byte-size.');\n            case 24:\n              _context9.next = 27;\n              break;\n            case 26:\n              throw new TypeError('Invalid magic number.');\n            case 27:\n              firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);\n              return _context9.abrupt(\"return\", new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options));\n            case 29:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9);\n      }));\n      function fromSource(_x5, _x6, _x7) {\n        return _fromSource.apply(this, arguments);\n      }\n      return fromSource;\n    }()\n  }]);\n  return GeoTIFF;\n}(GeoTIFFBase);\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nvar MultiGeoTIFF = /*#__PURE__*/function (_GeoTIFFBase2) {\n  _inherits(MultiGeoTIFF, _GeoTIFFBase2);\n  var _super3 = _createSuper(MultiGeoTIFF);\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  function MultiGeoTIFF(mainFile, overviewFiles) {\n    var _this5;\n    _classCallCheck(this, MultiGeoTIFF);\n    _this5 = _super3.call(this);\n    _this5.mainFile = mainFile;\n    _this5.overviewFiles = overviewFiles;\n    _this5.imageFiles = [mainFile].concat(overviewFiles);\n    _this5.fileDirectoriesPerFile = null;\n    _this5.fileDirectoriesPerFileParsing = null;\n    _this5.imageCount = null;\n    return _this5;\n  }\n  _createClass(MultiGeoTIFF, [{\n    key: \"parseFileDirectoriesPerFile\",\n    value: function () {\n      var _parseFileDirectoriesPerFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var requests;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(function (file) {\n                return file.parseFileDirectoryAt(file.firstIFDOffset);\n              }));\n              _context10.next = 3;\n              return Promise.all(requests);\n            case 3:\n              this.fileDirectoriesPerFile = _context10.sent;\n              return _context10.abrupt(\"return\", this.fileDirectoriesPerFile);\n            case 5:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function parseFileDirectoriesPerFile() {\n        return _parseFileDirectoriesPerFile.apply(this, arguments);\n      }\n      return parseFileDirectoriesPerFile;\n    }()\n    /**\n     * Get the n-th internal subfile of an image. By default, the first is returned.\n     *\n     * @param {number} [index=0] the index of the image to return.\n     * @returns {Promise<GeoTIFFImage>} the image at the given index\n     */\n  }, {\n    key: \"getImage\",\n    value: function () {\n      var _getImage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var index,\n          visited,\n          relativeIndex,\n          i,\n          imageFile,\n          ii,\n          ifd,\n          _args11 = arguments;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              index = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : 0;\n              _context11.next = 3;\n              return this.getImageCount();\n            case 3:\n              _context11.next = 5;\n              return this.parseFileDirectoriesPerFile();\n            case 5:\n              visited = 0;\n              relativeIndex = 0;\n              i = 0;\n            case 8:\n              if (!(i < this.imageFiles.length)) {\n                _context11.next = 26;\n                break;\n              }\n              imageFile = this.imageFiles[i];\n              ii = 0;\n            case 11:\n              if (!(ii < this.imageCounts[i])) {\n                _context11.next = 22;\n                break;\n              }\n              if (!(index === visited)) {\n                _context11.next = 17;\n                break;\n              }\n              _context11.next = 15;\n              return imageFile.requestIFD(relativeIndex);\n            case 15:\n              ifd = _context11.sent;\n              return _context11.abrupt(\"return\", new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source));\n            case 17:\n              visited++;\n              relativeIndex++;\n            case 19:\n              ii++;\n              _context11.next = 11;\n              break;\n            case 22:\n              relativeIndex = 0;\n            case 23:\n              i++;\n              _context11.next = 8;\n              break;\n            case 26:\n              throw new RangeError('Invalid image index');\n            case 27:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function getImage() {\n        return _getImage2.apply(this, arguments);\n      }\n      return getImage;\n    }()\n    /**\n     * Returns the count of the internal subfiles.\n     *\n     * @returns {Promise<number>} the number of internal subfile images\n     */\n  }, {\n    key: \"getImageCount\",\n    value: function () {\n      var _getImageCount2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var requests;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!(this.imageCount !== null)) {\n                _context12.next = 2;\n                break;\n              }\n              return _context12.abrupt(\"return\", this.imageCount);\n            case 2:\n              requests = [this.mainFile.getImageCount()].concat(this.overviewFiles.map(function (file) {\n                return file.getImageCount();\n              }));\n              _context12.next = 5;\n              return Promise.all(requests);\n            case 5:\n              this.imageCounts = _context12.sent;\n              this.imageCount = this.imageCounts.reduce(function (count, ifds) {\n                return count + ifds;\n              }, 0);\n              return _context12.abrupt(\"return\", this.imageCount);\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function getImageCount() {\n        return _getImageCount2.apply(this, arguments);\n      }\n      return getImageCount;\n    }()\n  }]);\n  return MultiGeoTIFF;\n}(GeoTIFFBase);\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport function fromUrl(_x8) {\n  return _fromUrl.apply(this, arguments);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nfunction _fromUrl() {\n  _fromUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(url) {\n    var options,\n      signal,\n      _args13 = arguments;\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) switch (_context13.prev = _context13.next) {\n        case 0:\n          options = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};\n          signal = _args13.length > 2 ? _args13[2] : undefined;\n          return _context13.abrupt(\"return\", GeoTIFF.fromSource(makeRemoteSource(url, options), signal));\n        case 3:\n        case \"end\":\n          return _context13.stop();\n      }\n    }, _callee13);\n  }));\n  return _fromUrl.apply(this, arguments);\n}\nexport function fromArrayBuffer(_x9, _x10) {\n  return _fromArrayBuffer.apply(this, arguments);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nfunction _fromArrayBuffer() {\n  _fromArrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(arrayBuffer, signal) {\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) switch (_context14.prev = _context14.next) {\n        case 0:\n          return _context14.abrupt(\"return\", GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal));\n        case 1:\n        case \"end\":\n          return _context14.stop();\n      }\n    }, _callee14);\n  }));\n  return _fromArrayBuffer.apply(this, arguments);\n}\nexport function fromFile(_x11, _x12) {\n  return _fromFile.apply(this, arguments);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nfunction _fromFile() {\n  _fromFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(path, signal) {\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) switch (_context15.prev = _context15.next) {\n        case 0:\n          return _context15.abrupt(\"return\", GeoTIFF.fromSource(makeFileSource(path), signal));\n        case 1:\n        case \"end\":\n          return _context15.stop();\n      }\n    }, _callee15);\n  }));\n  return _fromFile.apply(this, arguments);\n}\nexport function fromBlob(_x13, _x14) {\n  return _fromBlob.apply(this, arguments);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nfunction _fromBlob() {\n  _fromBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(blob, signal) {\n    return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n      while (1) switch (_context16.prev = _context16.next) {\n        case 0:\n          return _context16.abrupt(\"return\", GeoTIFF.fromSource(makeFileReaderSource(blob), signal));\n        case 1:\n        case \"end\":\n          return _context16.stop();\n      }\n    }, _callee16);\n  }));\n  return _fromBlob.apply(this, arguments);\n}\nexport function fromUrls(_x15) {\n  return _fromUrls.apply(this, arguments);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nfunction _fromUrls() {\n  _fromUrls = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(mainUrl) {\n    var overviewUrls,\n      options,\n      signal,\n      mainFile,\n      overviewFiles,\n      _args17 = arguments;\n    return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n      while (1) switch (_context17.prev = _context17.next) {\n        case 0:\n          overviewUrls = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : [];\n          options = _args17.length > 2 && _args17[2] !== undefined ? _args17[2] : {};\n          signal = _args17.length > 3 ? _args17[3] : undefined;\n          _context17.next = 5;\n          return GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n        case 5:\n          mainFile = _context17.sent;\n          _context17.next = 8;\n          return Promise.all(overviewUrls.map(function (url) {\n            return GeoTIFF.fromSource(makeRemoteSource(url, options));\n          }));\n        case 8:\n          overviewFiles = _context17.sent;\n          return _context17.abrupt(\"return\", new MultiGeoTIFF(mainFile, overviewFiles));\n        case 10:\n        case \"end\":\n          return _context17.stop();\n      }\n    }, _callee17);\n  }));\n  return _fromUrls.apply(this, arguments);\n}\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\nexport { Pool };\nexport { GeoTIFFImage };","map":{"version":3,"names":["GeoTIFFImage","DataView64","DataSlice","Pool","makeRemoteSource","makeBufferSource","makeFileReaderSource","makeFileSource","fieldTypes","fieldTagNames","arrayFields","geoKeyNames","writeGeotiff","globals","rgb","getDecoder","addDecoder","setLogger","default","BaseDecoder","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","RangeError","concat","parseGeoKeyDirectory","fileDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","i","key","location","count","offset","value","Error","substring","subarray","getValues","dataSlice","values","readMethod","fieldTypeLength","Uint8Array","readUint8","Int8Array","readInt8","Uint16Array","readUint16","Int16Array","readInt16","Uint32Array","readUint32","Int32Array","readInt32","Array","readUint64","readInt64","Float32Array","readFloat32","Float64Array","readFloat64","call","TextDecoder","decode","ImageFileDirectory","_createClass","nextIFDByteOffset","_classCallCheck","GeoTIFFImageIndexError","_Error","_inherits","_super","_createSuper","index","_this","_wrapNativeSuper","GeoTIFFBase","_readRasters","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","imageWindow","width","height","resX","resY","bbox","firstImage","usedImage","imageCount","imgBBox","_firstImage$getOrigin","_firstImage$getOrigin2","oX","oY","_firstImage$getResolu","_firstImage$getResolu2","rX","rY","usedBBox","allImages","image","_image$fileDirectory","subfileType","newSubfileType","_i2","_image","imgResX","imgResY","wnd","_firstImage$getOrigin3","_firstImage$getOrigin4","_oX","_oY","_usedImage$getResolut","_usedImage$getResolut2","imageResX","imageResY","_args","arguments","wrap","_callee$","_context","prev","next","length","undefined","window","getImage","sent","getImageCount","getBoundingBox","getOrigin","_slicedToArray","getResolution","SubfileType","NewSubfileType","push","sort","a","b","getWidth","getHeight","abrupt","Math","round","min","max","readRasters","_objectSpread","stop","apply","GeoTIFF","_GeoTIFFBase","_super2","source","littleEndian","bigTiff","firstIFDOffset","_this2","cache","ifdRequests","ghostValues","_getSlice","_callee2","size","fallbackSize","_callee2$","_context2","t0","fetch","t1","t2","t3","t4","getSlice","_x","_x2","_parseFileDirectoryAt","_callee3","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","_callee3$","_context3","covers","readOffset","indexOf","parseFileDirectoryAt","_x3","_requestIFD","_callee5","_this3","_callee5$","_context5","requestIFD","_callee4","previousIfd","_callee4$","_context4","_x4","_getImage","_callee6","ifd","_args6","_callee6$","_context6","dataView","_getImageCount","_callee7","hasNext","_callee7$","_context7","_getGhostValues","_callee8","_this4","detectionString","heuristicAreaSize","slice","valuesString","firstLine","metadataSize","fullString","_callee8$","_context8","split","Number","filter","line","map","forEach","_ref2","_ref3","getGhostValues","close","_fromSource","_callee9","signal","headerData","BOM","magicNumber","offsetByteSize","_callee9$","_context9","getUint16","TypeError","getUint64","getUint32","fromSource","_x5","_x6","_x7","MultiGeoTIFF","_GeoTIFFBase2","_super3","mainFile","overviewFiles","_this5","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","_parseFileDirectoriesPerFile","_callee10","requests","_callee10$","_context10","file","Promise","all","parseFileDirectoriesPerFile","_getImage2","_callee11","visited","relativeIndex","imageFile","ii","_args11","_callee11$","_context11","imageCounts","_getImageCount2","_callee12","_callee12$","_context12","reduce","ifds","fromUrl","_x8","_fromUrl","_callee13","url","_args13","_callee13$","_context13","fromArrayBuffer","_x9","_x10","_fromArrayBuffer","_callee14","arrayBuffer","_callee14$","_context14","fromFile","_x11","_x12","_fromFile","_callee15","path","_callee15$","_context15","fromBlob","_x13","_x14","_fromBlob","_callee16","blob","_callee16$","_context16","fromUrls","_x15","_fromUrls","_callee17","mainUrl","overviewUrls","_args17","_callee17$","_context17","writeArrayBuffer","metadata"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/geotiff/dist-module/geotiff.js"],"sourcesContent":["/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}