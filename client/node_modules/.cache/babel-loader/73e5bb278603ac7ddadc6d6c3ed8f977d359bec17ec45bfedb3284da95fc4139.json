{"ast":null,"code":"import _regeneratorRuntime from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { getDecoder } from './compression/index.js';\nvar defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 2 : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nvar Pool = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  function Pool() {\n    var _this = this;\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultPoolSize;\n    var createWorker = arguments.length > 1 ? arguments[1] : undefined;\n    _classCallCheck(this, Pool);\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise(function (resolve) {\n        import('./worker/decoder.js').then(function (module) {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then(function (create) {\n        _this._awaitingDecoder = null;\n        _this.workers = [];\n        for (var i = 0; i < size; i++) {\n          _this.workers.push({\n            worker: create(),\n            idle: true\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  _createClass(Pool, [{\n    key: \"decode\",\n    value: function () {\n      var _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fileDirectory, buffer) {\n        var _this2 = this;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this._awaitingDecoder) {\n                _context.next = 3;\n                break;\n              }\n              _context.next = 3;\n              return this._awaitingDecoder;\n            case 3:\n              return _context.abrupt(\"return\", this.size === 0 ? getDecoder(fileDirectory).then(function (decoder) {\n                return decoder.decode(fileDirectory, buffer);\n              }) : new Promise(function (resolve) {\n                var worker = _this2.workers.find(function (candidate) {\n                  return candidate.idle;\n                }) || _this2.workers[Math.floor(Math.random() * _this2.size)];\n                worker.idle = false;\n                var id = _this2.messageId++;\n                var onMessage = function onMessage(e) {\n                  if (e.data.id === id) {\n                    worker.idle = true;\n                    resolve(e.data.decoded);\n                    worker.worker.removeEventListener('message', onMessage);\n                  }\n                };\n                worker.worker.addEventListener('message', onMessage);\n                worker.worker.postMessage({\n                  fileDirectory: fileDirectory,\n                  buffer: buffer,\n                  id: id\n                }, [buffer]);\n              }));\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function decode(_x, _x2) {\n        return _decode.apply(this, arguments);\n      }\n      return decode;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.workers) {\n        this.workers.forEach(function (worker) {\n          worker.worker.terminate();\n        });\n        this.workers = null;\n      }\n    }\n  }]);\n  return Pool;\n}();\nexport default Pool;","map":{"version":3,"names":["getDecoder","defaultPoolSize","navigator","hardwareConcurrency","Pool","_this","size","arguments","length","undefined","createWorker","_classCallCheck","workers","_awaitingDecoder","messageId","Promise","resolve","then","module","create","i","push","worker","idle","_createClass","key","value","_decode","_asyncToGenerator","_regeneratorRuntime","mark","_callee","fileDirectory","buffer","_this2","wrap","_callee$","_context","prev","next","abrupt","decoder","decode","find","candidate","Math","floor","random","id","onMessage","e","data","decoded","removeEventListener","addEventListener","postMessage","stop","_x","_x2","apply","destroy","forEach","terminate"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/geotiff/dist-module/pool.js"],"sourcesContent":["import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}