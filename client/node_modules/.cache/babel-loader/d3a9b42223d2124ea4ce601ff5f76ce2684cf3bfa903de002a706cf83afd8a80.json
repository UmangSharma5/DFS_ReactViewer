{"ast":null,"code":"import _regeneratorRuntime from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _inherits from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/umang/iHub/DFS_ReactViewer/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\nvar Block = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  function Block(offset, length) {\n    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, Block);\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  _createClass(Block, [{\n    key: \"top\",\n    get: function get() {\n      return this.offset + this.length;\n    }\n  }]);\n  return Block;\n}();\nvar BlockGroup = /*#__PURE__*/_createClass(\n/**\n *\n * @param {number} offset\n * @param {number} length\n * @param {number[]} blockIds\n */\nfunction BlockGroup(offset, length, blockIds) {\n  _classCallCheck(this, BlockGroup);\n  this.offset = offset;\n  this.length = length;\n  this.blockIds = blockIds;\n});\nexport var BlockedSource = /*#__PURE__*/function (_BaseSource) {\n  _inherits(BlockedSource, _BaseSource);\n  var _super = _createSuper(BlockedSource);\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  function BlockedSource(source) {\n    var _this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$blockSize = _ref.blockSize,\n      blockSize = _ref$blockSize === void 0 ? 65536 : _ref$blockSize,\n      _ref$cacheSize = _ref.cacheSize,\n      cacheSize = _ref$cacheSize === void 0 ? 100 : _ref$cacheSize;\n    _classCallCheck(this, BlockedSource);\n    _this = _super.call(this);\n    _this.source = source;\n    _this.blockSize = blockSize;\n    _this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: function onEviction(blockId, block) {\n        _this.evictedBlocks.set(blockId, block);\n      }\n    });\n\n    /** @type {Map<number, Block>} */\n    _this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    _this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    _this.blockIdsToFetch = new Set();\n    _this.abortedBlockIds = new Set();\n    return _this;\n  }\n  _createClass(BlockedSource, [{\n    key: \"fileSize\",\n    get: function get() {\n      return this.source.fileSize;\n    }\n\n    /**\n     *\n     * @param {import(\"./basesource\").Slice[]} slices\n     */\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(slices, signal) {\n        var _this2 = this;\n        var blockRequests, missingBlockIds, allBlockIds, _iterator, _step, _step$value, offset, length, top, fileSize, firstBlockOffset, current, _blockId2, missingRequests, _i, _missingBlockIds, blockId, abortedBlockRequests, abortedBlockIds, _iterator2, _step2, _blockId, block, blocks, failedBlocks, requiredBlocks;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              blockRequests = [];\n              missingBlockIds = [];\n              allBlockIds = [];\n              this.evictedBlocks.clear();\n              _iterator = _createForOfIteratorHelper(slices);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  _step$value = _step.value, offset = _step$value.offset, length = _step$value.length;\n                  top = offset + length;\n                  fileSize = this.fileSize;\n                  if (fileSize !== null) {\n                    top = Math.min(top, fileSize);\n                  }\n                  firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n                  for (current = firstBlockOffset; current < top; current += this.blockSize) {\n                    _blockId2 = Math.floor(current / this.blockSize);\n                    if (!this.blockCache.has(_blockId2) && !this.blockRequests.has(_blockId2)) {\n                      this.blockIdsToFetch.add(_blockId2);\n                      missingBlockIds.push(_blockId2);\n                    }\n                    if (this.blockRequests.has(_blockId2)) {\n                      blockRequests.push(this.blockRequests.get(_blockId2));\n                    }\n                    allBlockIds.push(_blockId2);\n                  }\n                }\n\n                // allow additional block requests to accumulate\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              _context.next = 8;\n              return wait();\n            case 8:\n              this.fetchBlocks(signal);\n\n              // Gather all of the new requests that this fetch call is contributing to `fetch`.\n              missingRequests = [];\n              for (_i = 0, _missingBlockIds = missingBlockIds; _i < _missingBlockIds.length; _i++) {\n                blockId = _missingBlockIds[_i];\n                // The requested missing block could already be in the cache\n                // instead of having its request still be outstanding.\n                if (this.blockRequests.has(blockId)) {\n                  missingRequests.push(this.blockRequests.get(blockId));\n                }\n              }\n\n              // Actually await all pending requests that are needed for this `fetch`.\n              _context.next = 13;\n              return Promise.allSettled(blockRequests);\n            case 13:\n              _context.next = 15;\n              return Promise.allSettled(missingRequests);\n            case 15:\n              // Perform retries if a block was interrupted by a previous signal\n              abortedBlockRequests = [];\n              abortedBlockIds = allBlockIds.filter(function (id) {\n                return _this2.abortedBlockIds.has(id) || !_this2.blockCache.has(id);\n              });\n              abortedBlockIds.forEach(function (id) {\n                return _this2.blockIdsToFetch.add(id);\n              });\n              // start the retry of some blocks if required\n              if (!(abortedBlockIds.length > 0 && signal && !signal.aborted)) {\n                _context.next = 41;\n                break;\n              }\n              this.fetchBlocks(null);\n              _iterator2 = _createForOfIteratorHelper(abortedBlockIds);\n              _context.prev = 21;\n              _iterator2.s();\n            case 23:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 31;\n                break;\n              }\n              _blockId = _step2.value;\n              block = this.blockRequests.get(_blockId);\n              if (block) {\n                _context.next = 28;\n                break;\n              }\n              throw new Error(\"Block \".concat(_blockId, \" is not in the block requests\"));\n            case 28:\n              abortedBlockRequests.push(block);\n            case 29:\n              _context.next = 23;\n              break;\n            case 31:\n              _context.next = 36;\n              break;\n            case 33:\n              _context.prev = 33;\n              _context.t0 = _context[\"catch\"](21);\n              _iterator2.e(_context.t0);\n            case 36:\n              _context.prev = 36;\n              _iterator2.f();\n              return _context.finish(36);\n            case 39:\n              _context.next = 41;\n              return Promise.allSettled(abortedBlockRequests);\n            case 41:\n              if (!(signal && signal.aborted)) {\n                _context.next = 43;\n                break;\n              }\n              throw new AbortError('Request was aborted');\n            case 43:\n              blocks = allBlockIds.map(function (id) {\n                return _this2.blockCache.get(id) || _this2.evictedBlocks.get(id);\n              });\n              failedBlocks = blocks.filter(function (i) {\n                return !i;\n              });\n              if (!failedBlocks.length) {\n                _context.next = 47;\n                break;\n              }\n              throw new AggregateError(failedBlocks, 'Request failed');\n            case 47:\n              // create a final Map, with all required blocks for this request to satisfy\n              requiredBlocks = new Map(zip(allBlockIds, blocks)); // TODO: satisfy each slice\n              return _context.abrupt(\"return\", this.readSliceData(slices, requiredBlocks));\n            case 49:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[21, 33, 36, 39]]);\n      }));\n      function fetch(_x, _x2) {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n    /**\n     *\n     * @param {AbortSignal} signal\n     */\n  }, {\n    key: \"fetchBlocks\",\n    value: function fetchBlocks(signal) {\n      var _this3 = this;\n      // check if we still need to\n      if (this.blockIdsToFetch.size > 0) {\n        var groups = this.groupBlocks(this.blockIdsToFetch);\n\n        // start requesting slices of data\n        var groupRequests = this.source.fetch(groups, signal);\n        var _loop = function _loop(groupIndex) {\n          var group = groups[groupIndex];\n          var _iterator3 = _createForOfIteratorHelper(group.blockIds),\n            _step3;\n          try {\n            var _loop2 = function _loop2() {\n              var blockId = _step3.value;\n              // make an async IIFE for each block\n              _this3.blockRequests.set(blockId, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                var response, blockOffset, o, t, data, block;\n                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) switch (_context2.prev = _context2.next) {\n                    case 0:\n                      _context2.prev = 0;\n                      _context2.next = 3;\n                      return groupRequests;\n                    case 3:\n                      _context2.t0 = groupIndex;\n                      response = _context2.sent[_context2.t0];\n                      blockOffset = blockId * _this3.blockSize;\n                      o = blockOffset - response.offset;\n                      t = Math.min(o + _this3.blockSize, response.data.byteLength);\n                      data = response.data.slice(o, t);\n                      block = new Block(blockOffset, data.byteLength, data, blockId);\n                      _this3.blockCache.set(blockId, block);\n                      _this3.abortedBlockIds.delete(blockId);\n                      _context2.next = 23;\n                      break;\n                    case 14:\n                      _context2.prev = 14;\n                      _context2.t1 = _context2[\"catch\"](0);\n                      if (!(_context2.t1.name === 'AbortError')) {\n                        _context2.next = 22;\n                        break;\n                      }\n                      // store the signal here, we need it to determine later if an\n                      // error was caused by this signal\n                      _context2.t1.signal = signal;\n                      _this3.blockCache.delete(blockId);\n                      _this3.abortedBlockIds.add(blockId);\n                      _context2.next = 23;\n                      break;\n                    case 22:\n                      throw _context2.t1;\n                    case 23:\n                      _context2.prev = 23;\n                      _this3.blockRequests.delete(blockId);\n                      return _context2.finish(23);\n                    case 26:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }, _callee2, null, [[0, 14, 23, 26]]);\n              }))());\n            };\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              _loop2();\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        };\n        for (var groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n          _loop(groupIndex);\n        }\n        this.blockIdsToFetch.clear();\n      }\n    }\n\n    /**\n     *\n     * @param {Set} blockIds\n     * @returns {BlockGroup[]}\n     */\n  }, {\n    key: \"groupBlocks\",\n    value: function groupBlocks(blockIds) {\n      var sortedBlockIds = Array.from(blockIds).sort(function (a, b) {\n        return a - b;\n      });\n      if (sortedBlockIds.length === 0) {\n        return [];\n      }\n      var current = [];\n      var lastBlockId = null;\n      var groups = [];\n      var _iterator4 = _createForOfIteratorHelper(sortedBlockIds),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var blockId = _step4.value;\n          if (lastBlockId === null || lastBlockId + 1 === blockId) {\n            current.push(blockId);\n            lastBlockId = blockId;\n          } else {\n            groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n            current = [blockId];\n            lastBlockId = blockId;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));\n      return groups;\n    }\n\n    /**\n     *\n     * @param {import(\"./basesource\").Slice[]} slices\n     * @param {Map} blocks\n     */\n  }, {\n    key: \"readSliceData\",\n    value: function readSliceData(slices, blocks) {\n      var _this4 = this;\n      return slices.map(function (slice) {\n        var top = slice.offset + slice.length;\n        if (_this4.fileSize !== null) {\n          top = Math.min(_this4.fileSize, top);\n        }\n        var blockIdLow = Math.floor(slice.offset / _this4.blockSize);\n        var blockIdHigh = Math.floor(top / _this4.blockSize);\n        var sliceData = new ArrayBuffer(slice.length);\n        var sliceView = new Uint8Array(sliceData);\n        for (var blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n          var block = blocks.get(blockId);\n          var delta = block.offset - slice.offset;\n          var topDelta = block.top - top;\n          var blockInnerOffset = 0;\n          var rangeInnerOffset = 0;\n          var usedBlockLength = void 0;\n          if (delta < 0) {\n            blockInnerOffset = -delta;\n          } else if (delta > 0) {\n            rangeInnerOffset = delta;\n          }\n          if (topDelta < 0) {\n            usedBlockLength = block.length - blockInnerOffset;\n          } else {\n            usedBlockLength = top - block.offset - blockInnerOffset;\n          }\n          var blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n          sliceView.set(blockView, rangeInnerOffset);\n        }\n        return sliceData;\n      });\n    }\n  }]);\n  return BlockedSource;\n}(BaseSource);","map":{"version":3,"names":["QuickLRU","BaseSource","AbortError","AggregateError","wait","zip","Block","offset","length","data","arguments","undefined","_classCallCheck","_createClass","key","get","BlockGroup","blockIds","BlockedSource","_BaseSource","_inherits","_super","_createSuper","source","_this","_ref","_ref$blockSize","blockSize","_ref$cacheSize","cacheSize","call","blockCache","maxSize","onEviction","blockId","block","evictedBlocks","set","Map","blockRequests","blockIdsToFetch","Set","abortedBlockIds","fileSize","value","_fetch","_asyncToGenerator","_regeneratorRuntime","mark","_callee","slices","signal","_this2","missingBlockIds","allBlockIds","_iterator","_step","_step$value","top","firstBlockOffset","current","_blockId2","missingRequests","_i","_missingBlockIds","abortedBlockRequests","_iterator2","_step2","_blockId","blocks","failedBlocks","requiredBlocks","wrap","_callee$","_context","prev","next","clear","_createForOfIteratorHelper","s","n","done","Math","min","floor","has","add","push","err","e","f","fetchBlocks","Promise","allSettled","filter","id","forEach","aborted","Error","concat","t0","finish","map","i","abrupt","readSliceData","stop","fetch","_x","_x2","apply","_this3","size","groups","groupBlocks","groupRequests","_loop","groupIndex","group","_iterator3","_step3","_loop2","_callee2","response","blockOffset","o","t","_callee2$","_context2","sent","byteLength","slice","delete","t1","name","sortedBlockIds","Array","from","sort","a","b","lastBlockId","_iterator4","_step4","_this4","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","Uint8Array","delta","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView"],"sources":["/home/umang/iHub/DFS_ReactViewer/client/node_modules/geotiff/dist-module/source/blockedsource.js"],"sourcesContent":["import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}